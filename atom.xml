<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ykgarfield</title>
  
  <subtitle>ykgarfield&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ykgarfield.github.io/"/>
  <updated>2019-01-21T09:01:39.546Z</updated>
  <id>https://ykgarfield.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 fesacr 源码中总结出的 Java 代码编写注意事项</title>
    <link href="https://ykgarfield.github.io/2019/01/20/Java/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/%E4%BB%8E%20fesacr%20%E6%BA%90%E7%A0%81%E4%B8%AD%E6%80%BB%E7%BB%93%E5%87%BA%E7%9A%84%20Java%20%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://ykgarfield.github.io/2019/01/20/Java/代码规范/从 fesacr 源码中总结出的 Java 代码编写注意事项/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-01-21T09:01:39.546Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 <a href="https://github.com/alibaba/fescar" target="_blank" rel="noopener">fesacr</a> 的源码, 从中也看到有一些代码书写不规范或是有误的地方.本文总结了自己看源码过程中目前发现的一些问题, 都已在 github 上提了 issue 或 pr.</p><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>在 Java API 中一般有两种方式对字符串进行格式化:</p><ul><li><code>String.format()</code></li><li><code>MessageFormat.format()</code></li></ul><p>以上两种方法的主要差异其实就是要格式化的字符串中的占位符, <code>String.format()</code> 使用类似于 <code>%s</code>(表示字符)这样的占位符, <code>MessageFormat.format()</code> 使用 <code>{0}</code>(<code>{参数索引}</code>).</p><p>而我们在项目开发中, 都会使用日志框架, 在打印日志的时候, 也会使用占位符进行格式化字符串, 占位符一般为 <code>{}</code>, 所以在项目开发过程中可能会搞错这几种方式, 搞混了这几种占位符.所以需要格外的注意.</p><p>对于 <code>String.format()</code> 而言, IDEA 其实已经提供了较好的验证支持, </p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/从_fesacr_源码中总结出的_Java_代码编写注意事项/String.format占位符错误警告.jpg" alt="String.format()占位符错误警告"></p><p>相关 issue 可见: <a href="https://github.com/alibaba/fescar/issues/122" target="_blank" rel="noopener">https://github.com/alibaba/fescar/issues/122</a></p><h2 id="不要使用-File-rename-对文件重命名"><a href="#不要使用-File-rename-对文件重命名" class="headerlink" title="不要使用 File.rename() 对文件重命名"></a>不要使用 File.rename() 对文件重命名</h2><p>如果我们想对文件进行重命名, 首先想到的就是使用 <code>File.rename()</code> 方法, 但是仔细看看此方法的说明, 其实这个方法是不靠谱的, 也就是说有可能会失败.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Renames the file denoted by this abstract pathname.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Many aspects of the behavior of this method are inherently</span></span><br><span class="line"><span class="comment"> * platform-dependent: The rename operation might not be able to move a</span></span><br><span class="line"><span class="comment"> * file from one filesystem to another, it might not be atomic, and it</span></span><br><span class="line"><span class="comment"> * might not succeed if a file with the destination abstract pathname</span></span><br><span class="line"><span class="comment"> * already exists.  The return value should always be checked to make sure</span></span><br><span class="line"><span class="comment"> * that the rename operation was successful.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Note that the &#123;<span class="doctag">@link</span> java.nio.file.Files&#125; class defines the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.file.Files#move move&#125; method to move or rename a file in a</span></span><br><span class="line"><span class="comment"> * platform independent manner.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>在几年前, 在用 Jetty 的时候, 也是遇到过这个问题.后来排查原因, 就是因为 <code>File.rename()</code> 引起的.所以最好不要使用此方法重命名.可以使用 <code>Files.move()</code> 或者是 apache <code>commons-io</code> 包中的方法.</p><p>相关 issue 可见: <a href="https://github.com/alibaba/fescar/issues/92" target="_blank" rel="noopener">https://github.com/alibaba/fescar/issues/92</a></p><h2 id="关闭-io-流的时候避免冗余的-close-方法调用"><a href="#关闭-io-流的时候避免冗余的-close-方法调用" class="headerlink" title="关闭 io 流的时候避免冗余的 close() 方法调用"></a>关闭 io 流的时候避免冗余的 close() 方法调用</h2><p>有如下一个获取文件 channel 的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(...);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">// 获取 channel</span></span><br><span class="line">FileChannel fileChannel = raf.getChannel();</span><br><span class="line"><span class="comment">// 写数据</span></span><br><span class="line">fileChannel.write(...);</span><br></pre></td></tr></table></figure><p>一般我们可以通过上述的方式写入数据到文件中, 在最后关闭的时候, 大部分时候可能是为了保险起见, 会使用如下的代码关闭相关的资源:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.close();</span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure><p>但是如下仔细查看 <code>RandomAccessFile.close()</code> 方法的源码, 就会发现, 其实这个方法的内部会自动调用 <code>fileChannel.close()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (closed) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">closed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 自动关闭 channel</span></span><br><span class="line"><span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">channel.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd.closeAll(<span class="keyword">new</span> Closeable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   close0();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出, 关闭文件相关资源的时候, 只需要调用 <code>RandomAccessFile.close()</code>, 而不需要再调用一次 <code>fileChannel.close()</code>.</p><p>相关 issue 可见: <a href="https://github.com/alibaba/fescar/issues/127" target="_blank" rel="noopener">https://github.com/alibaba/fescar/issues/127</a></p><h2 id="Netty-服务端设置-SO-KEEPALIVE-是没有用的"><a href="#Netty-服务端设置-SO-KEEPALIVE-是没有用的" class="headerlink" title="Netty 服务端设置 SO_KEEPALIVE 是没有用的"></a>Netty 服务端设置 SO_KEEPALIVE 是没有用的</h2><p>在用 Netty 进行网络编程的时候, 通过会设置 <code>SO_KEEPALIVE</code> 选项为 <code>true</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.serverBootstrap.group(<span class="keyword">this</span>.eventLoopGroupBoss, <span class="keyword">this</span>.eventLoopGroupWorker)</span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line">.option(ChannelOption.SO_BACKLOG, nettyServerConfig.getSoBackLogSize())</span><br><span class="line">.option(ChannelOption.SO_REUSEADDR, <span class="keyword">true</span>)</span><br><span class="line"><span class="comment">// 设置 SO_KEEPALIVE 选项</span></span><br><span class="line">.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>初看上面的代码感觉是没有任何问题的, 有可能项目跑起来的时候也注意不到有什么问题.看如果真的细看启动日志就会发现, 使用上面的代码启动后, 会打印如下的警告日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN io.netty.bootstrap.ServerBootstrap - Unknown channel option &apos;SO_KEEPALIVE&apos; for channel ...</span><br></pre></td></tr></table></figure><p>这个问题的解决方案也很简单, 应该使用 <code>childOption()</code> 方法.这一点比较难以察觉的, 有时候需要观察下启动日志.</p><p>相关 issue 可见: <a href="https://github.com/alibaba/fescar/issues/150" target="_blank" rel="noopener">https://github.com/alibaba/fescar/issues/150</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看 &lt;a href=&quot;https://github.com/alibaba/fescar&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fesacr&lt;/a&gt; 的源码, 从中也看到有一些代码书写不规范或是有误的地方.本文总结了自己看源码过程中目前发现的
      
    
    </summary>
    
      <category term="Java" scheme="https://ykgarfield.github.io/categories/Java/"/>
    
      <category term="代码规范" scheme="https://ykgarfield.github.io/categories/Java/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="fescar" scheme="https://ykgarfield.github.io/tags/fescar/"/>
    
      <category term="代码规范" scheme="https://ykgarfield.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>第2章-分解策略</title>
    <link href="https://ykgarfield.github.io/2019/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Microservice-Patterns(%E8%AF%91)/%E7%AC%AC2%E7%AB%A0-%E5%88%86%E8%A7%A3%E7%AD%96%E7%95%A5/"/>
    <id>https://ykgarfield.github.io/2019/01/15/微服务/Microservice-Patterns(译)/第2章-分解策略/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-01-21T09:17:02.642Z</updated>
    
    <content type="html"><![CDATA[<p>这章包含:</p><ul><li>理解软件架构及其重要性</li><li>通过应用按业务能力分解和按子域分解的分解模式, 将应用程序分解为服务</li><li>用来自领域驱动设计(DDD)的有界上下文(bounded context)概念来理清数据并使分解更容易</li></ul><p>有时候你必须小心你的愿望.经过激烈的游说, Mary 最终说服了业务部门, 迁移到微服务架构是正确的.Mary 感到既兴奋又有些害怕, 她和她的架构师们开了一个长达一上午的会, 讨论从哪里开始.在讨论期间, 很明显, 微服务架构模式语言的某些方面, 如部署和服务发现, 是新的和不熟悉的, 但是很简单.微服务架构的核心挑战是将应用程序分解为服务.因此, 架构的第一个也是最重要的方面是服务的定义.当他们站在白板旁时, FTGO 团队想知道该怎么做!</p><p>在本章中, 您将学习如何为应用程序定义微服务架构.我将描述将应用程序分解为服务的策略.您将了解到服务是围绕业务关注点组织的, 而不是围绕技术关注点组织的.我还展示了如何使用来自领域驱动设计(DDD)的思想来消除 god 类, god 类是贯穿整个应用程序使用的类, 它们会导致妨碍分解的复杂依赖关系.</p><p>本章首先从软件架构概念的角度定义微服务架构.然后, 我将描述从应用程序的需求开始定义微服务架构的过程.我将讨论将应用程序分解为服务集合的策略、遇到的障碍以及如何克服它们.让我们从审查软件架构的概念开始.</p><h1 id="微服务体系结构究竟是什么"><a href="#微服务体系结构究竟是什么" class="headerlink" title="微服务体系结构究竟是什么?"></a>微服务体系结构究竟是什么?</h1><p>第 1 章描述了微服务架构的关键思想是功能分解.您不是开发一个大型应用程序, 而是将应用程序构造为一组服务.一方面, 将微服务架构描述为一种功能分解是有用的.但另一方面, 它留下了几个未解的问题, 包括微服务架构如何与概念更加广泛的软件架构相关联? 什么是服务? 服务的大小有多重要?</p><p>为了回答这些问题, 我们需要后退一步, 看看<em>软件架构</em>是什么意思.软件应用程序的架构是它的高层结构, 它由组成部分和这些部分之间的依赖关系组成.正如您将在本节中看到的, 应用程序的架构是多维的, 因此有多种方法来描述它.架构之所以重要, 是因为它决定了应用程序的软件质量属性或 <em>ilities</em>(可参考 <a href="https://zh.wikipedia.org/wiki/非功能性需求).传统上" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/非功能性需求).传统上</a>, 架构的目标是可伸缩性、可靠性和安全性.但是今天，架构还支持快速和安全的软件交付, 这一点很重要.您将了解到, 微服务架构是一种架构风格, 它使应用程序具有很高的可维护性、可测试性和可部署性.</p><p>我将通过描述软件架构的概念及其重要性来开始这一节.接下来, 我将讨论架构风格的概念.然后, 我将微服务架构定义为一种特殊的架构风格让我们从软件架构的概念开始.</p><h2 id="什么是软件架构-它为什么重要"><a href="#什么是软件架构-它为什么重要" class="headerlink" title="什么是软件架构? 它为什么重要?"></a>什么是软件架构? 它为什么重要?</h2><p>架构显然很重要.至少有两个会议专门讨论这个主题: O ‘Reilly 软件架构会议(<a href="https://conferences.oreilly.com/softw-architecture)和" target="_blank" rel="noopener">https://conferences.oreilly.com/softw-architecture)和</a> SATURN 会议(<a href="https://resources.sei.cmu.edu/news-events/events/saturn/).许多开发人员都有成为架构师的目标.但是什么是架构" target="_blank" rel="noopener">https://resources.sei.cmu.edu/news-events/events/saturn/).许多开发人员都有成为架构师的目标.但是什么是架构</a>? 它为什么重要?</p><p>为了回答这个问题, 我首先定义了术语软件架构的含义.然后, 我将讨论应用程序的架构是多维的以及如何使用视图或蓝图的集合进行最佳描述.然后我描述了软件架构的重要性, 因为它对应用程序的软件质量属性有影响.</p><p><strong>软件架构的定义</strong><br>软件架构有许多定义.例如, 请参阅 <a href="https://en.wikiquote.org/wiki/Software_architecture" target="_blank" rel="noopener">https://en.wikiquote.org/wiki/Software_architecture</a> 来阅读其中一些.我最喜欢的定义来自 Len Bass 和他在软件工程研究所(<a href="http://www.sei.cmu.edu)的同事" target="_blank" rel="noopener">www.sei.cmu.edu)的同事</a>, 他们在将软件架构作为一门学科建立起来方面发挥了关键作用.他们对软件架构的定义如下:</p><blockquote><p>计算系统的软件架构是对系统进行推理所需要的一组结构, 它包括软件元素、它们之间的关系以及两者的属性.<br>   — Bass 等人编写的软件架构文档.</p></blockquote><p>这显然是一个相当抽象的定义.但它的本质是, 应用程序的架构是将其分解为部分(元素)和这些部分之间的关系(关系).分解之所以重要有几个原因:</p><ul><li>它促进了劳动和知识的分工.它使具有专业知识的多个人员(或多个团队)能够在一个应用程序上高效地一起工作.</li><li>它定义了软件元素如何交互.</li></ul><p>分解成各个部分以及这些部分之间的关系决定了应用程序的性能.</p><p><strong>软件架构的4+1视图模型</strong></p><p>更具体地说, 可以从多个角度查看应用程序的架构, 就像可以从结构、管道、电气和其他角度查看建筑物的体系结构一样.Phillip Krutchen 写了一篇描述软件架构的 4+1 视图模型的经典论文, “架构蓝图-软件架构的 ‘4+1’ 视图模型”(<a href="http://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf).图" target="_blank" rel="noopener">www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf).图</a> 2.1 所示的 4+1 模型定义了软件架构的四个不同视图.它们都描述了架构的一个特定方面, 并由一组特定的软件元素和它们之间的关系组成.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.1_The_4+1_view_model_defines_four_different_views_of_a_software_architecture.jpg" alt="Figure 2.1 The 4+1 view model defines four different views of a software architecture"></p><p>每个视图的目的如下:</p><ul><li><em>逻辑视图</em>-由开发人员创建的软件元素.在面向对象语言中, 这些元素是类和包.它们之间的关系是类和包之间的关系, 包括继承、关联和依赖.</li><li><em>实现视图</em>-构建系统的输出.该视图由模块和组件组成, 模块表示打包的代码, 组件是由一个或多个模块组成的可执行或可部署单元.在 Java 中, 模块是 JAR 文件,组件通常是 WAR 文件或可执行 JAR 文件.它们之间的关系包括模块之间的依赖关系和组件与模块之间的组合关系.</li><li><em>进程视图</em>-运行时的组件.每个元素都是一个进程, 进程之间的关系表示进程间通信.</li><li><em>部署视图</em>-如何将进程映射到机器上.该视图中的元素由(物理或虚拟)机器和进程组成.机器之间的关系代表了网络.这个视图还描述了进程和机器之间的关系.</li></ul><p>除了这四个视图之外, 还有场景-4+1 模型中的 +1-动画视图.每个场景描述特定视图中的各个架构组件如何协作以处理请求.例如, 逻辑视图中的一个场景显示了类如何协作.类似地, 进程视图中的场景显示了进程如何协作.</p><p>4+1 视图模型是描述应用程序架构的一种很好的方法.每个视图描述架构的一个重要方面, 场景说明视图的元素如何协作.现在让我们看看为什么架构是重要的.</p><p><strong>为什么架构是重要的?</strong></p><p>应用程序有两类需求.第一类包括功能需求, 它们定义了应用程序必须做什么.它们通常以用例或用户故事的形式出现.架构与功能需求的关系非常小.您可以用几乎任何架构实现功能需求, 甚至是一个大泥球.</p><p>架构非常重要, 因为它使应用程序能够满足第二类需求: 其服务质量需求.这些也被称为质量属性, 即所谓的质量.服务质量要求定义了运行时质量, 如可伸缩性和可靠性.它们还定义了开发周期的质量, 包括可维护性、可测试性和可部署性.您为应用程序选择的架构决定了它如何很好地满足这些质量要求.</p><h2 id="架构风格概览"><a href="#架构风格概览" class="headerlink" title="架构风格概览"></a>架构风格概览</h2><p>在现实世界中, 建筑物的建筑往往遵循一种特定的风格, 如维多利亚时代、美国工匠或装饰艺术.每一种风格都是一套限制建筑特色和建筑材料的设计决策.架构风格的概念也适用于软件.David Garlan 和 Mary Shaw(软件架构介绍, 1994 年 1 月, <a href="https://www.cs.cmu.edu/afs/cs/project/able/ftp/intro_softarch/intro_softarch.pdf)是软件架构学科的先驱" target="_blank" rel="noopener">https://www.cs.cmu.edu/afs/cs/project/able/ftp/intro_softarch/intro_softarch.pdf)是软件架构学科的先驱</a>, 他们定义了如下的架构风格:</p><blockquote><p>架构风格根据结构组织的模式定义了一系列此类系统.更具体地说, 架构风格决定了在该风格的实例中可以使用的组件和连接器(connectors)的词汇表, 以及关于如何组合它们的一组约束.</p></blockquote><p>特定的架构风格提供了元素(组件)和关系(连接器)的有限调色板, 您可以从中定义应用程序架构的视图.应用程序通常使用架构风格的组合.例如, 在本节后面, 我将描述单体架构是如何将实现视图构造为单个(可执行/可部署)组件的架构风格.微服务架构将应用程序构造为一组散耦合的服务.</p><p><strong>分层的架构风格</strong></p><p>架构风格的经典例子是分层架构.分层架构将软件元素组织成层.每个层都有一组定义良好的职责.分层架构还限制了层之间的依赖关系.一个层只能依赖于它下面的层(如果严格的分层)或者它下面的任何层.</p><p>您可以将分层架构应用于前面讨论的四个视图中的任何一个.流行的三层架构是应用于逻辑视图的分层架构.它将应用程序的类组织成以下层:</p><ul><li><em>表示层</em>-包含实现用户界面或外部 API 的代码</li><li><em>业务逻辑层</em>-包含了业务逻辑</li><li><em>持久层</em>-实现了与数据库交互的逻辑</li></ul><p>分层架构是架构风格的一个很好的例子, 但是它也有一些明显的缺点:</p><ul><li><em>单一表示层</em>-它并不表示应用程序可能被多个系统调用这一事实.</li><li><em>单一持久层</em>-它并不表示应用程序可能与多个数据库交互这一事实.</li><li><em>根据持久层定义业务逻辑层</em>-从理论上讲, 这种依赖性阻止您在没有数据库的情况下测试业务逻辑.</li></ul><p>而且, 分层架构错误地表示了设计良好的应用程序中的依赖关系.业务逻辑通常定义定义数据访问方法的接口或接口 repository.持久层定义实现 repository 接口的 DAO 类.换句话说, 依赖关系与分层体系结构所描述的相反.</p><p>让我们来看一个克服这些缺点的替代架构:六边形架构.</p><p><strong>六边形架构风格</strong></p><p><em>六角形架构</em>是分层架构之外的另一种选择.如图 2.2 所示, 六边形架构风格以一种将业务逻辑置于中心的方式组织逻辑视图.与表示层不同, 应用程序有一个或多个<em>入站适配器(inbound adapters)</em>, 通过调用业务逻辑处理来自外部的请求.类似地, 应用程序没有数据持久层, 而是有一个或多个<em>出站适配器(outbound adapters)</em>, 这些适配器由业务逻辑调用并调用外部应用程序.此架构的一个关键特征和优点是业务逻辑不依赖于适配器.相反, 他们依赖它.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.2_An_example_of_a_hexagonal_architecture.jpg" alt="Figure 2.2 An example of a hexagonal architecture"></p><p>业务逻辑有一个或多个接口.<em>端口(port)</em> 定义了一组操作, 以及业务逻辑如何与外部操作交互.例如, 在 Java 中, 端口通常是 Java 接口。有两种端口: 入站端口和出站端口.入站端口是业务逻辑公开的 API, 它允许外部应用程序调用它.入站端口的一个例子是服务接口, 它定义了服务的公共方法.出站端口是业务逻辑调用外部系统的方式.输出端口的一个例子是存储库接口, 它定义了一组数据访问操作.</p><p>围绕业务逻辑的是适配器.与端口一样, 适配器有两种类型: 入站适配器和出站适配器.入站适配器通过调用入站端口处理来自外部的请求.入站适配器的一个例子是 Spring MVC 控制器, 它实现了一组 REST 端点或一组 web 页面.另一个示例是订阅消息的 message broker 客户机.多个入站适配器可以调用相同的入站端口.</p><p>出站适配器实现出站端口, 并通过调用外部应用程序或服务处理来自业务逻辑的请求.出站适配器的一个例子是实现访问数据库操作的<em>数据访问对象</em>(DAO)类.另一个例子是调用远程服务的代理类.出站适配器也可以发布事件.</p><p>六边形架构风格的一个重要优点是, 它将业务逻辑与适配器中的表示逻辑和数据访问逻辑解耦.业务逻辑不依赖于表示逻辑或数据访问逻辑.由于这种解耦, 独立测试业务逻辑要容易得多.另一个好处是, 它更准确地反映了现代应用程序的架构.业务逻辑可以通过多个适配器调用, 每个适配器实现一个特定的 API 或 UI.业务逻辑还可以调用多个适配器, 每个适配器调用不同的外部系统.六边形架构是描述微服务架构中每个服务的架构的一种很好的方法.</p><p>分层结构和六角形架构都是架构风格的例子.它们都定义了架构的构建块, 并对它们之间的关系施加了约束.六角形架构和分层架构以三层架构的形式组织逻辑视图.现在让我们将微服务架构定义为组织实现视图的架构风格.</p><h2 id="微服务架构是一种架构风格"><a href="#微服务架构是一种架构风格" class="headerlink" title="微服务架构是一种架构风格"></a>微服务架构是一种架构风格</h2><p>我已经讨论了 4+ 1视图模型和架构风格, 因此现在可以定义单体和微服务架构.它们都是架构风格.单体架构是一种架构风格, 它将实现视图结构为单个组件:单个可执行文件或 WAR 文件.这个定义与其他视图无关.例如, 一个单体应用程序可以拥有一个逻辑视图, 该视图按照六角形架构的线条组织.</p><blockquote><p>模式: 单体架构<br>将应用程序构建为单个可执行/可部署组件.见 <a href="http://microservices.io/patterns/monolithic.html" target="_blank" rel="noopener">http://microservices.io/patterns/monolithic.html</a>.</p></blockquote><p>微服务架构也是一种架构风格.它将实现视图构建为一组多个组件: 可执行文件或 WAR 文件.组件是服务, 连接器是使这些服务能够协作的通信协议.每个服务都有自己的逻辑视图架构, 通常是六边形的架构.图 2.3 显示了 FTGO 应用程序可能的微服务架构.该架构中的服务与业务功能相对应, 例如订单管理和餐厅管理.</p><blockquote><p>模式: 微服务架构<br>将应用程序构造为松耦合的、独立部署的服务集合, 见 <a href="http://microservices.io/patterns/microservices.html" target="_blank" rel="noopener">http://microservices.io/patterns/microservices.html</a>.</p></blockquote><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.3_A_possible_microservice_architecture_for_the_FTGO_application.jpg" alt="Figure 2.3 A possible microservice architecture for the FTGO application"></p><p>在本章的后面, 我将描述什么是<em>业务能力</em>.服务之间的连接器是使用诸如 REST API 和异步消息传递等进程间通信机制实现的.第 3 章更详细地讨论了进程间通信.</p><p>微服务架构强加的一个关键约束是服务是松耦合的.因此, 对于服务如何协作有一些限制.为了解释这些限制, 我将尝试定义术语<em>服务</em>, 描述松散耦合意味着什么, 并告诉您为什么这很重要.</p><p><strong>什么是服务?</strong></p><p><em>服务</em>是一个独立的、可独立部署的软件组件, 它实现了一些有用的功能.图 2.4 显示了服务的外部视图, 在本例中是 <code>Order Service</code>.服务具有一个 API, 该 API 为其客户端提供对其功能的访问.有两种类型的操作: 命令和查询.API 由命令、查询和事件组成.命令, 比如 <code>createOrder()</code> 执行操作并更新数据.查询, 比如 <code>findOrderById()</code> 检索数据.服务还发布由其客户端消费的事件, 比如 <code>OrderCreated</code>.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.4_shows_the_external_view_of_a_service.jpg" alt="Figure 2.4 shows the external view of a service"></p><p>服务的 API 封装了它的内部实现.与单体不同, 开发人员不能编写绕过 API 的代码.因此, 微服务体系结构强制应用程序的模块化.</p><p>微服务架构中的每个服务都有自己的架构, 可能还有技术栈.但是典型的服务具有六角形架构.它的 API 是由与服务的业务逻辑交互的适配器实现的.操作适配器调用业务逻辑, 事件适配器发布业务逻辑发出的事件.</p><p><strong>什么是松耦合</strong></p><p>微服务架构的一个重要特征是服务是松耦合的(<a href="https://en.wikipedia.org/wiki/Loose_coupling)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Loose_coupling)</a>, 与服务的所有交互都是通过 API 进行的, API 封装了服务的实现细节.这使得服务的实现可以在不影响其客户端的情况下进行更改.松耦合服务是改进应用程序开发时间周期(包括可维护性和可测试性)的关键.它们更容易理解、更改和测试.</p><p>对服务进行松耦合并仅通过 API 进行协作的要求禁止服务通过数据库进行通信.您必须将服务的持久数据视为类的字段并保持它们的私有.保持数据私有使开发人员能够更改其服务的数据库模式, 而不必花费时间与处理其他服务的开发人员进行协调.不共享数据库表还可以改进运行时隔离.例如, 它确保一个服务不能持有阻塞另一个服务的数据库锁.但是, 稍后您将了解不共享数据库的一个缺点是, 维护数据一致性和跨服务查询更加复杂.</p><p><strong>共享库的角色</strong></p><p>开发人员通常将功能打包在一个库(模块)中, 以便多个应用程序可以重用它, 而无需重复代码.毕竟, 如果没有 Maven 或 npm 存储库, 我们今天会怎样呢? 您可能还想在微服务架构中使用共享库.从表面上看, 这似乎是减少服务中的代码重复的好方法.但是您需要确保不会意外地在服务之间引入耦合.</p><p>例如, 假设多个服务需要更新 <code>Order</code> 业务对象.一种方法是将该功能打包为多个服务使用的库.一方面, 使用库可以消除代码重复.另一方面, 考虑当需求影响 <code>Order</code> 业务对象的方式发生变化时会发生什么.您需要同时重新构建和部署这些服务.更好的方法是将可能更改的功能(如订单管理)实现为服务.</p><p>您应该努力将库用于不太可能更改的功能.例如, 在一个典型的应用程序中, 每个服务实现一个通用的 <code>Money</code> 类是没有意义的.相反, 您应该创建服务使用的库.</p><p><strong>服务规模通常不重要</strong></p><p><em>微服务</em>这个词的一个问题是, 你听到的第一件事就是<em>微小</em>.这意味着服务应该非常小.其他基于大小的术语, 如迷你型服务(miniservice)或 nanoservice 也是如此.实际上, 大小并不是一个有用的度量标准.</p><p>更好的目标是将设计良好的服务定义为能够由一个小团队开发的服务, 该团队的开发周期最短, 与其他团队的协作也最少.从理论上讲, 一个团队可能只负责一个服务, 所以服务绝不是<em>微小</em>的.相反, 如果一个服务需要一个大的团队或者需要很长的时间来测试, 那么将团队和服务分开可能是有意义的.或者, 如果您经常因为对其他服务的更改而需要更改某个服务, 或者如果它触发了其他服务中的更改, 则说明它不是松耦合的.您甚至可能构建一个分布式的单体.</p><p>微服务架构将应用程序构建为一组小的、松耦合的服务.因此, 它改进了开发时间属性-可维护性、可测试性、可部署性等等-并使组织能够更快地开发更好的软件.它还改进了应用程序的可伸缩性, 尽管这不是主要目标.要为应用程序开发微服务架构, 需要标识服务并确定它们如何协作.我们来看看怎么做.</p><h1 id="定义应用程序微服务架构"><a href="#定义应用程序微服务架构" class="headerlink" title="定义应用程序微服务架构"></a>定义应用程序微服务架构</h1><p>我们应该如何定义微服务架构? 与任何软件开发工作一样, 起点是编写需求, 希望是领域专家, 也许是现有的应用程序.与许多软件开发一样, 定义架构是一门艺术, 而不是科学.本节描述一个简单的三步流程, 如图 2.5 所示, 用于定义应用程序的架构.但是, 重要的是要记住, 这不是一个你可以机械地遵循的过程.它很可能是迭代的, 并涉及很多创造力.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.5_A_three-step_process_for_defining_an_application’s_microservice_architecture.jpg" alt="Figure 2.5 A three-step process for defining an application’s microservice architecture"></p><p>应用程序用于处理请求, 因此定义其架构的第一步是将应用程序的需求提取到关键请求中.但是, 我没有使用 REST 或消息传递等特定 IPC 技术来描述请求, 而是使用了更抽象的系统操作(system operation)概念.系统操作是应用程序必须处理的请求的抽象.它可以是更新数据的命令, 也可以是检索数据的查询.每个命令的行为都是根据抽象领域模型定义的, 抽象领域模型也是从需求派生出来的.系统操作成为说明服务如何协作的架构场景.</p><p>流程中的第二步是确定服务的分解.有几种策略可供选择.一种策略起源于业务架构的规程, 它定义与业务功能相对应的服务.另一种策略是围绕领域驱动的设计子领域组织服务.最终的结果是围绕业务概念而不是技术概念组织的服务.</p><p>定义应用程序架构的第三步是确定每个服务的 API.为此, 要将第一步中标识的每个系统操作分配给服务.服务可以完全独立地实现操作.或者, 它可能需要与其他服务协作.在这种情况下, 您将确定服务如何协作, 这通常需要服务来支持其他操作.您还需要决定我在第3 章中描述的实现每个服务的 API 的IPC 机制.</p><p>分解有几个障碍.首先是网络延迟.您可能会发现, 由于服务之间的往返(round-trips)太多, 特定的分解是不切实际的.分解的另一个障碍是服务之间的同步通信降低了可用性.您可能需要使用第 3 章中描述的自包含(self-contained)服务的概念.第三个障碍是跨服务维护数据一致性的需求.您通常需要使用在第 4 章中讨论的 sagas.分解的第四个也是最后一个障碍是所谓的 god 类, 它们在整个应用程序中使用.幸运的是, 您可以使用领域驱动设计的概念来消除 god 类.</p><p>本节首先描述如何标识应用程序的操作.之后, 我们将研究将应用程序分解为服务的策略和指导方针, 以及分解的障碍和如何解决它们.最后, 我将描述如何定义每个服务的 API.</p><h2 id="识别系统操作-system-operations"><a href="#识别系统操作-system-operations" class="headerlink" title="识别系统操作(system operations)"></a>识别系统操作(system operations)</h2><p>定义应用程序架构的第一步是定义系统操作.起点是应用程序的需求, 包括用户故事及其关联的用户场景(注意, 这些场景与架构场景不同).使用图 2.6 所示的两步流程标识和定义系统操作.这个过程的灵感来自 Craig Larman 的《应用 UML 和模式》(Prentice Hall, 2004)一书中介绍的面向对象设计过程(参见<a href="http://www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns).第一步创建高层域模型" target="_blank" rel="noopener">http://www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns).第一步创建高层域模型</a>, 该模型由提供用于描述系统操作的词汇表的关键类组成.第二步识别系统操作, 并根据域模型描述每个操作的行为.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.6_System_operations_are_derived_from_the_application’s_requirements_using_a_two-step_process.jpg" alt="Figure 2.6 System operations are derived from the application’s requirements using a two-step process"></p><p>领域模型主要来源于用户描述的名词, 系统操作主要来源于动词.您还可以使用一种称为事件风暴(Event Stroming)的技术来定义域模型, 我在第 5 章中讨论了这种技术.每个系统操作的行为是根据它对一个或多个域对象的影响以及它们之间的关系来描述的.系统操作可以创建、更新或删除域对象, 也可以创建或销毁它们之间的关系.</p><p>让我们来看看如何定义一个高级域模型.之后, 我将根据域模型定义系统操作.</p><p><strong>创建高级域模型</strong></p><p>定义系统操作过程的第一步是为应用程序勾画一个高级域模型.请注意, 这个域模型比最终要实现的要简单得多.应用程序甚至不会有单个域模型, 因为您很快就会了解到, 每个服务都有自己的域模型.尽管进行了极大的简化, 但是高层领域模型在这个阶段仍然很有用, 因为它定义了描述系统操作行为的词汇表.</p><p>领域模型是使用标准技术创建的, 例如分析故事和场景中的名词并与领域专家交流.考虑一下, 例如, <code>下订单(Place Order)</code>故事.我们可以将这个故事扩展到许多用户场景, 包括这个场景:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个消费者</span><br><span class="line">和一个餐厅</span><br><span class="line">以及该餐厅可提供的送货地址/时间</span><br><span class="line">以及满足餐厅最低订购量的总订购量</span><br><span class="line">当顾客为餐馆下订单时</span><br><span class="line">那么消费者的信用卡就被授权了</span><br><span class="line">并且订单是在 PENDING_ACCEPTANCE 状态下创建的</span><br><span class="line">订单与消费者关联</span><br><span class="line">订单与餐厅关联</span><br></pre></td></tr></table></figure><p>此用户场景中的名词暗示存在各种类, 包括 <code>Consumer</code>、<code>Order</code>、<code>Restaurant</code> 和 <code>CreditCard</code>.</p><p>类似地，<code>接受订单(Accept Order)</code> 的故事可以扩展到如下场景:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定处于 PENDING_ACCEPTANCE 状态的订单和可用于配送订单的快递员</span><br><span class="line">当餐馆接受订单时承诺在特定时间内准备好</span><br><span class="line">然后将订单的状态更改为 ACCEPTED</span><br><span class="line">订单的 promiseByTime 被更新为 promised 时间</span><br><span class="line">并且快递员被指定来配送订单</span><br></pre></td></tr></table></figure><p>这个场景表明存在 <code>Courier</code> 和 <code>Delivery</code> 类.经过几次迭代分析后的最终结果将是一个域模型, 该模型毫无疑问地由这些类和其他类, 如 <code>MenuItem</code> 和 <code>Address</code> 组成.图2.7 是显示关键类的类图.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.7_The_key_classes_in_the_FTGO_domain_model.jpg" alt="Figure 2.7 The key classes in the FTGO domain model"></p><p>每个类的职责如下:</p><ul><li><code>Consumer</code>-下单的消费者</li><li><code>Order</code>-由消费者下的订单.它描述了订单并追踪它的状态.</li><li><code>OrderLineItem</code>-订单中的一行条目.</li><li><code>DeliveryInfo</code>-配送订单的时间和地点.</li><li><code>Restaurant</code>-为顾客准备送货单的餐馆.</li><li><code>MenuItem</code>-餐厅菜单上的一个项目.</li><li><code>Courier</code>-向消费者配送订单的快递员.它跟踪快递员的可用性和他们当前的位置.</li><li><code>Address</code>-消费者或餐馆的地址.</li><li><code>Location</code>-快递员的纬度和经度.</li></ul><p>类图, 如图 2.7 所示, 说明了应用程序架构的一个方面.但如果没有动画场景, 它也不过是一张漂亮的图片.下一步是定义与架构场景相对应的系统操作.</p><p><strong>定义系统操作</strong><br>定义了高层域模型之后, 下一步是确定应用程序必须处理的请求.UI 的细节超出了本书的范围, 但是您可以想象, 在每个用户场景中, UI 都将请求后端业务逻辑来检索和更新数据.FTGO 主要是一个 web 应用程序, 这意味着大多数请求都是基于 HTTP 的, 但也有可能一些客户端会使用消息传递.因此, 与其使用特定的协议, 不如使用更抽象的系统操作概念来表示请求.</p><p>有两种类型的系统操作:</p><ul><li><code>命令(Commands)</code>-创建、更新和删除数据的系统操作</li><li><code>查询(Queries)</code>-读取(查询)数据的系统操作</li></ul><p>最终, 这些系统操作将与 REST、RPC 或消息传递端点相对应, 但目前抽象地考虑它们是有用的.让我们首先识别一些命令.</p><p>识别系统命令的一个很好的起点是分析用户故事和场景中的动词.例如, 考虑 <code>Place Order</code> 的故事.显然, 系统必须提供一个 <code>Create Order</code> 的操作.许多其他故事单独映射到系统命令.表 2.1 列出了一些关键的系统命令.</p><p><strong>表 2.1 FTGO 应用程序的关键系统命令</strong></p><table><thead><tr><th>参与者</th><th>故事</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>消费者</td><td>创建订单</td><td><code>createOrder()</code></td><td>创建一个订单</td></tr><tr><td>餐厅</td><td>接受订单</td><td><code>acceptOrder()</code></td><td>表示餐厅已接受订单, 并承诺在指定时间内准备好</td></tr><tr><td>餐厅</td><td>准备就绪的订单</td><td><code>noteOrderReadyForPickup()</code></td><td>表明订单已经准备就绪</td></tr><tr><td>快递员</td><td>更新位置</td><td><code>noteUpdatedLocation()</code></td><td>更新快递员的当前位置</td></tr><tr><td>快递员</td><td>送货上门</td><td><code>noteDeliveryPickedUp()</code></td><td>表示快递员在将订单送货上门</td></tr><tr><td>快递员</td><td>配送完成</td><td><code>noteDeliveryDelivered()</code></td><td>表示快递员已送达订单</td></tr></tbody></table><p>命令具有一个规范, 该规范根据域模型类定义其参数、返回值和行为.行为规范由调用操作时必须为 true 的前置条件和调用操作后为 true 的后置条件组成.例如, 下面是 <code>createOrder()</code> 系统操作的规范:</p><table><thead><tr><th>系统操作</th><th>规范</th></tr></thead><tbody><tr><td>操作</td><td><code>createOrder</code>(consumer id, payment method, delivery address, delivery time, restaurant id, order line items)</td></tr><tr><td>返回</td><td><code>orderId</code>, …</td></tr><tr><td>前置条件</td><td>1. 消费者存在并且可以下单 <br> 2. 行项目和餐厅的菜单项对应 <br> 3. 配送地址和时间在餐厅的服务范围内</td></tr><tr><td>后置条件</td><td>1. 消费者的信用卡被授权支付订单总额 <br> 2. 订单被创建, 状态为 <code>PENDING_ACCEPTANCE</code></td></tr></tbody></table><p>这些先决条件反映了前面描述的 <code>Place Order</code> 用户场景中的 <code>给定(given)</code> 项.后置条件反映了场景中的 <code>然后(then)</code>.当调用系统操作时, 它将验证前置条件, 并执行使后置条件为 true 所需的操作.</p><p>下面是 <code>acceptOrder()</code> 系统操作的规范:</p><table><thead><tr><th>系统操作</th><th>规范</th></tr></thead><tbody><tr><td>操作</td><td><code>acceptOrder(restaurantId, orderId, readyByTime)</code></td></tr><tr><td>返回</td><td>-</td></tr><tr><td>前置条件</td><td>1. <code>订单状态(order.status)</code> 是 <code>等待接受(PENDING_ACCEPTANCE)</code>. <br> 2. 快递员可以配送订单.</td></tr><tr><td>后置条件</td><td>1. <code>订单状态(order.status)</code>变为 <code>接受了(ACCEPTED)</code>. <br> 2. <code>订单准备时间(order.readyByTime)</code>变为 <code>准备时间(readyByTime)</code>. <br> 3. 快递员被分配去配送订单.</td></tr></tbody></table><p>它的前置和后置条件反映了前面的用户场景.</p><p>大多数与架构相关的系统操作是命令.不过, 有时检索数据的查询也很重要.</p><p>除了实现命令之外, 应用程序还必须实现查询.查询为 UI 提供了用户决策所需的信息.在这个阶段, 我们并没有为 FTGO 应用程序设计一个特定的 UI, 但是考虑一下, 例如, 当消费者下订单时的流程:</p><ol><li>用户输入送货地址和时间.</li><li>系统展示可配送的餐馆.</li><li>用户选择餐馆.</li><li>系统展示菜单.</li><li>用户选择商品并付款.</li><li>系统创建订单.</li></ol><p>此用户场景建议以下查询:</p><ul><li><code>findAvailableRestaurants(deliveryAddress, deliveryTime)</code>-检索能够在指定时间送达指定地址的餐厅.</li><li><code>findRestaurantMenu(id)</code>-检索包含菜单项的餐厅信息.</li></ul><p>在这两个查询中, <code>findAvailableRestaurants()</code> 可能是架构上最重要的查询.这是一个涉及地理搜索(geosearch)的复杂查询.查询的地理搜索组件包括查找所有的点-餐馆-在一个位置附近-送货地址.它还会过滤掉那些需要准备和取餐时关门的餐厅.此外, 性能非常关键, 因为只要消费者想要下订单, 就会执行此查询.</p><p>高层领域模型和系统操作捕获应用程序所做的事情.它们有助于驱动应用程序架构的定义.每个系统操作的行为都用域模型来描述的.每个重要的系统操作代表一个架构上重要的场景, 这是架构描述的一部分.</p><p>定义了系统操作之后, 下一步是识别应用程序的服务.正如前面提到的, 没有一个机械化的过程可以遵循.然而, 您可以使用各种分解策略.每一种方法都从不同的角度解决问题, 并使用自己的术语.但是对于所有的策略, 最终的结果是相同的: 由服务组成的架构主要围绕业务而不是技术概念进行组织.</p><p>让我们看看第一个策略, 它定义了与业务功能相对应的服务.</p><h2 id="通过应用按业务能力分解模式定义服务"><a href="#通过应用按业务能力分解模式定义服务" class="headerlink" title="通过应用按业务能力分解模式定义服务"></a>通过应用按业务能力分解模式定义服务</h2><p>创建微服务架构的一种策略是按业务能力分解.业务架构建模中的概念, 业务能力是业务为产生价值所做的事情.给定业务的功能集取决于业务类型.例如, 保险公司的功能通常包括承保、索赔管理、计费、合规等等.在线商店的功能包括订单管理、库存管理、配送等.</p><blockquote><p><strong>模式: 按照业务功能分解</strong><br>根据业务能力定义服务.见 <a href="http://microservices.io/patterns/decomposition/decompose-by-business-capability.html" target="_blank" rel="noopener">http://microservices.io/patterns/decomposition/decompose-by-business-capability.html</a></p></blockquote><p><strong>业务功能定义了组织的工作</strong></p><p>组织的业务能力捕捉组织的业务是什么.它们通常是稳定的, 而不是组织如何管理业务, 组织的业务随时间而变化, 有时变化很大.随着越来越多的人使用技术实现许多业务流程的自动化, 这一点在如今尤其明显.例如, 不久前你把支票交给出纳员存入银行.后来, 用 ATM 存入支票成为可能.如今, 你可以用智能手机方便地存入大多数支票.如您所见, 存款支票业务功能一直保持稳定, 但其实现方式已发生了巨大变化.</p><p><strong>识别业务功能</strong></p><p>通过分析组织的目的、结构和业务流程, 确定组织的业务功能.每个业务功能都可以看作是服务, 除了它是面向业务的, 而不是面向技术的.它的规范由各种组件组成, 包括输入、输出和服务级别协议.例如, 保险承保能力的输入是消费者的申请, 输出包括批准和价格.</p><p>业务能力通常关注于特定的业务对象.例如, 索赔业务对象是索赔管理功能的焦点.功能通常可以分解为子功能, 例如, 索赔管理功能有几个子功能, 包括索赔信息管理、索赔审查和索赔支付管理.</p><p>不难想象, FTGO 的业务能力包括:</p><ul><li>供应商管理<ul><li><em>快递员管理</em>-管理快递员信息</li><li><em>餐厅信息管理</em>-管理餐厅的菜单和其他信息, 包括位置和营业时间.</li></ul></li><li>消费者管理-管理消费者的信息</li><li>订单接收和履行<ul><li><em>订单管理</em>-允许消费者创建和管理订单</li><li><em>餐厅订单管理</em>-管理餐厅订单的准备工作</li><li><em>物流</em></li><li><em>快递可用性管理</em>-管理快递员对送货单的实时可用性</li><li><em>配送管理</em>-给消费者配送订单</li></ul></li><li>会计核算<ul><li><em>消费者会计核算</em>-管理消费者的帐单</li><li><em>餐厅会计核算</em>-管理参订的支付信息</li><li><em>快递员会计核算</em>-管理给快递员的支付信息</li></ul></li></ul><p>顶级功能包括供应商管理、消费者管理、订单接收和履行以及会计核算.可能还会有许多其他顶级功能, 包括与营销相关的功能.大多数顶级功能被分解为子功能.例如, 接受订单和履行被分解为五个子功能.</p><p>有趣的是, 这种能力层次结构有三种与餐厅相关的能力: 餐厅信息管理、餐厅订单管理和餐厅会计核算.这是因为它们代表了餐厅运营的三个非常不同的方面.</p><p>下面我们将看下如何用业务功能来定义服务.</p><p><strong>从业务功能到服务</strong></p><p>一旦确定了业务功能, 就可以为每个功能或相关功能组定义服务.图 2.8 显示了 FTGO 应用程序从功能到服务的映射.一些顶级功能, 例如会计核算功能, 被映射到服务.在其他情况下, 子功能映射到服务.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.8_Mapping_FTGO_business_capabilities_to_services.jpg" alt="Figure 2.8 Mapping FTGO business capabilities to services"></p><p>决定将哪个级别的功能层次结构映射到服务, 因为这在某种程度上是主观的.我对这种特定映射的理由如下:</p><ul><li>我将供应商管理的子功能映射到两个服务, 因为餐厅和快递员是非常不同类型的供应商.</li><li>我将接受订单和履行的功能映射到三个服务, 每个服务负责流程的不同阶段.我将快递员可用性管理和配送管理功能结合在一起, 并将它们映射到单个服务, 因为它们是紧密交织在一起的.</li><li>我将会计核算功能映射到它自己的服务, 因为不同类型的会计核算看起来很相似.</li></ul><p>稍后, 将(餐馆和快递员的)支付与(消费者的)账单分开可能是有意义的.</p><p>围绕功能组织服务的一个关键优点是, 由于它们是稳定的, 因此产生的架构也相对稳定.架构的各个组件可能随着业务方面的变化而演进, 但是架构仍然保持不变.</p><p>尽管如此, 重要的是要记住图 2.8 所示的服务仅仅是定义架构的第一次尝试.随着我们对应用领域的了解越来越多, 它们可能会随着时间而发展.特别是, 架构定义过程中的一个重要步骤是研究服务如何在每个关键架构服务中协作.例如, 您可能会发现由于进程间通信过多, 导致关节式分解是低效的, 您必须组合服务.相反, 服务的复杂性可能会增长到值得将其拆分为多个服务的程度.更重要的是, 在 2.2.5 节中, 我描述了分解的几个障碍, 它们可能会导致您重新考虑您的决策.</p><p>让我们看看另一种分解基于领域驱动设计的应用程序的方法.</p><h2 id="通过应用子域模式分解来定义服务"><a href="#通过应用子域模式分解来定义服务" class="headerlink" title="通过应用子域模式分解来定义服务"></a>通过应用子域模式分解来定义服务</h2><p>DDD, 正如 Eric Evans(Addison-Wesley Professional, 2003)在他的优秀著作《领域驱动设计》中描述的那样, 是一种构建以面向对象领域模型开发为中心的复杂软件应用程序的方法.<em>域模式(domain mode)</em> 以可用于解决该域内问题的形式捕获关于该域的知识.它定义了团队使用的词汇表, DDD 称之为 <em>通用语言(Ubiquitous  Language)</em>.领域模型紧密地反映在应用程序的设计和实现中.在应用微服务架构时, DDD 有两个非常有用的概念: 子域(subdomains)和有界上下文(bounded contexts).</p><blockquote><p><strong>模式: 通过子域分解</strong><br>根据 DDD 子域定义服务, 详见 <a href="http://microservices.io/patterns/decomposition/decompose-by-subdomain.html" target="_blank" rel="noopener">http://microservices.io/patterns/decomposition/decompose-by-subdomain.html</a>.</p></blockquote><p>DDD 与传统的企业建模方法有很大的不同, 后者为整个企业创建一个单独的模型.例如, 在这种模型中, 每个业务实体(如客户、订单等)都有一个单独的定义.这种建模的问题在于, 让组织的不同部分同意一个模型是一项艰巨的任务.此外, 它还意味着从组织的给定部分的角度来看, 模型对于他们的需求过于复杂.此外, 领域模型可能令人混淆, 因为组织的不同部分可能对不同的概念使用相同的术语, 也可能对相同的概念使用不同的术语.DDD 通过定义多个领域模型来避免这些问题, 每个模型都具有显式的作用域.</p><p>DDD 为每个子域定义了一个单独的领域模型.子域是<em>域</em>的一部分, DDD 术语表示应用程序的问题空间.子领域的识别使用与识别业务功能相同的方式: 分析业务并识别不同的专业领域.最终的结果很可能是类似于业务功能的子域.FTGO 中的子域示例包括订单接收、订单管理、厨房管理、配送和财务.正如您所看到的, 这些子域与前面描述的业务功能非常相似.</p><p>DDD 将域模型的范围称为<em>有界上下文(bounded context)</em>.有界上下文包括实现模型的代码工件.在使用微服务架构时, 每个有界上下文都是一个服务或一组服务.我们可以通过应用 DDD 并为每个子域定义服务来创建微服务架构.图 2.9 显示了子域如何映射到服务, 每个子域都有自己的域模型.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.9_From_subdomains_to_services.jpg" alt="Figure 2.9 From subdomains to services"></p><p>DDD 和微服务架构几乎完全一致.子域和有界上下文的 DDD 概念很好地映射到微服务架构中的服务.此外, 微服务架构拥有服务的自治团队的概念完全符合 DDD 的概念, 即每个领域模型由单个团队拥有和开发.更好的是, 正如我在本节后面所描述的, 具有自己的域模型的子域的概念是消除 god 类从而使分解更容易的一种很好的方法.</p><p>按子域分解和按业务能力分解是定义应用程序微服务架构的两种主要模式.然而, 分解有一些有用的指导原则, 它们的根源在于面向对象的设计.让我们来看一看.</p><h2 id="分解指导原则"><a href="#分解指导原则" class="headerlink" title="分解指导原则"></a>分解指导原则</h2><p>到目前为止, 我们已经了解了定义微服务架构的主要方法.在应用微服务架构模式时, 我们还可以采用和使用面向对象设计的一些原则.这些原则由 Robert C. Martin 创建的, 并在他的经典著作《使用 Booch 方法设计面向对象的 C++ 应用程序》(Prentice Hall, 1995)中进行了描述.第一个原则是单一职责原则(SRP), 用于定义类的职责.第二个原则是共同封闭原则(CCP), 用于将类组织到包中.让我们看看这些原则, 并看看如何将它们应用于微服务架构.</p><p><strong>单一职责原则</strong><br>软件架构和设计的主要目标之一是确定每个软件元素的职责.单一职责原则如下:</p><blockquote><p>一个类应该只有一个更改的原因.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Robert C. Martin</p></blockquote><p>类所具有的每个职责都是该类更改的潜在原因.如果一个类有多个独立更改的职责, 那么这个类就不会是稳定的.通过遵循SRP, 您可以定义每个类都有一个职责, 因此也就有了进行更改的一个原因.</p><p>我们可以在定义微服务体系结构时应用 SRP, 并创建小型、内聚的服务, 每个服务都有一个职责.这将减少服务的规模并增加其稳定性.新的 FTGO 架构是 SRP 运行的一个例子.将食物送到消费者手中的每一个方面-订单接收、订单准备和配送-都是独立服务的责任.</p><p><strong>共同封闭原则</strong><br>另一个有用的原则是共同封闭原则:</p><p>另一个有用的原则是共同封闭原则:</p><blockquote><p>包中的类应该针对相同类型的更改聚集在一起.影响包的更改会影响包中的所有类.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Robert C. Martin </p></blockquote><p>其思想是, 如果两个类因为相同的基本原因而同步改变, 那么它们属于同一个包.例如, 这些类可能实现特定业务规则的不同方面.它的目标是, 当业务规则发生更改时, 开发人员只需要更改少量包中的代码(理想情况下只需要更改一个包).坚持 CCP 可以显著提高应用程序的可维护性.</p><p>我们可以在创建微服务架构和包组件时应用 CCP, 这些组件出于相同的原因更改为相同的服务.这样做将最小化在某些需求发生更改时需要更改和部署的服务数量.理想情况下, 更改只会影响单个团队和单个服务.CCP 是分布式单体反模式的解毒剂.</p><p>SRP 和 CCP 是 Bob Martin 提出的 11 条原则中的 2 条.它们在开发微服务架构时特别有用.其余九条原则用于设计类和包.有关 SRP、CCP 和其他 OOD 原则的更多信息, 请参见 Bob Martin 网站上的文章 “面向对象设计的原则”(<a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)" target="_blank" rel="noopener">http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)</a>.</p><p>按业务能力和按子域分解以及 SRP 和 CCP 是将应用程序分解为服务的良好技术.为了应用它们并成功地开发微服务架构, 您必须解决一些事务管理和进程间通信问题.</p><h2 id="将应用程序分解为服务的障碍"><a href="#将应用程序分解为服务的障碍" class="headerlink" title="将应用程序分解为服务的障碍"></a>将应用程序分解为服务的障碍</h2><p>从表面上看, 通过定义与业务功能或子域相对应的服务来创建微服务架构的策略看起来很简单.然而, 你可能会遇到一些障碍:</p><ul><li>网络延迟</li><li>同步通信降低了可用性</li><li>维护跨服务数据一致性</li><li>获得数据的一致视图</li><li>阻止分解的 God 类</li></ul><p>让我们看看每个障碍, 从网络延迟开始.</p><p><strong>网络延迟</strong><br><em>网络延迟</em>是分布式系统中一直存在的问题.您可能会发现, 对服务的特定分解会导致两个服务之间的大量往返(round-trips).有时, 您可以通过实现一个批处理 API 来在一次往返中获取多个对象, 从而将延迟降低到可接受的程度.但在其他情况下, 解决方案是组合服务, 用语言级别的方法或函数调用替换昂贵的 IPC(进程间通信).</p><p><strong>同步通信降低了可用性</strong><br>另一个问题是如何以不降低可用性的方式实现服务间通信.例如, 实现 <code>createOrder()</code> 操作最简单的方法是让 <code>订单服务</code> 使用 REST 同步调用其他服务, 使用像 REST 这样的协议的缺点是它降低了 <code>订单服务</code> 的可用性.如果其他服务不可用, 它将无法创建订单.有时这是一个值得权衡的问题, 但是在第 3 章中, 您将了解到使用异步消息传递(消除紧密耦合并提高可用性)通常是更好的选择.</p><p><strong>维护跨服务数据一致性</strong><br>另一个挑战是维护跨服务数据一致性.一些系统操作需要更新多个服务中的数据.例如, 当餐馆接收订单时, <code>厨房服务(Kitchen Service)</code>和<code>配送服务(Delivery Service)</code>都必须进行更新.<code>厨房服务</code>改变了票据的状态.<code>配送服务</code>安排了订单的配送.这两个更新都必须以原子方式完成.</p><p>传统的解决方案是使用基于提交的两阶段分布式事务管理机制.但是正如您将在第 4 章中看到的, 对于现代应用程序来说, 这不是一个好的选择, 您必须使用一种非常不同的事务管理方法, 这就是 saga.<code>saga</code> 是使用消息传递进行协调的一系列本地事务.Saga 比传统的 ACID 事务更复杂, 但在许多情况下都能很好地工作.Saga 的一个限制是它们最终是一致的.如果您需要以原子方式更新某些数据, 那么它必须驻留在单个服务中, 这可能成为分解的障碍.</p><p><strong>获得数据的一致视图</strong><br>分解的另一个障碍是无法跨多个数据库获得真正一致的数据视图.在单体应用程序中, ACID 事务的属性保证查询将返回数据库的一致视图.相反, 在微服务架构中, 即使每个服务的数据库是一致的, 您也无法获得数据的全局一致视图.如果您需要一些数据的一致视图, 那么它必须驻留在单个服务中, 这可能妨碍分解.幸运的是, 在实践中这很少是一个问题.</p><p><strong>阻止分解的 God 类</strong><br>分解的另一个障碍是所谓的 God 类的存在.God 类是整个应用程序中使用的臃肿类(<a href="http://wiki.c2.com/?GodClass).God" target="_blank" rel="noopener">http://wiki.c2.com/?GodClass).God</a> 类通常为应用程序的许多不同方面实现业务逻辑.它通常有大量字段映射到具有许多列的数据库表.大多数应用程序至少具有这些类中的一个, 每个类代表一个对该领域至关重要的概念: 银行帐户、电子商务订单、保险策略等等.因为 God 类将应用程序的许多不同方面的状态和行为捆绑在一起, 所以要将使用它的任何业务逻辑拆分为服务, 它是不可逾越的障碍.</p><p><code>Order</code> 类是 FTGO 应用程序中 God 类的一个很好的例子.这并不奇怪-毕竟, FTGO 的目的是向客户发送食品订单.系统的很多方面都涉及到订单.如果 FTGO 应用程序只有一个领域模型, 那么 <code>Order</code> 类将是一个非常大的类.它将具有与应用程序的许多不同部分相对应的状态和行为.图 2.10 显示了将使用传统建模技术创建的该类的结构.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.10_The_Order_god_class_is_bloated_with_numerous_responsibilities..jpg" alt="Figure 2.10 The Order god class is bloated with numerous responsibilities."></p><p>如您所见, <code>Order</code> 类具有与订单处理、餐厅订单管理、配送和支付相对应的字段和方法.这个类还有一个复杂的状态模型, 因为一个模型必须描述来自应用程序不同部分的状态转换.在当前形式下, 该类使得将代码分割为服务变得极其困难.</p><p>一种解决方案是将 <code>Order</code> 类打包到一个库中, 并创建一个中央订单数据库.处理订单的所有服务都使用这个库并访问数据库.这种方法的问题在于, 它违反了微服务架构的关键原则之一, 并导致了不受欢迎的紧密耦合.例如, 对 <code>Order</code> schema 的任何更改都需要团队同步更新代码.</p><p>另一种解决方案是将 <code>订单</code> 数据库封装在 <code>订单服务</code> 中, 其他服务调用该订单服务来检索和更新订单.这种设计的问题是订单服务将是一个数据服务, 其贫血领域模型包含很少或没有业务逻辑.这两个选项都不吸引人, 但幸运的是, DDD 提供了一个解决方案.</p><p>一种更好的方法是应用 DDD, 并将每个服务作为一个单独的子域.并使用其自己的领域模型.这意味着 FTGO 应用程序中与订单相关的每个服务都有自己的领域模型和 <code>Order</code> 类的版本.多领域模型好处的一个很好的例子是配送服务.它对订单的视图, 如图 2.11 所示, 非常简单: 取货地址、取货时间、送货地址和送货时间.而且, 配送服务使用更合适的配送名称, 而不是将其称为订单.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.11_The_Delivery_Service_domain_model.jpg" alt="Figure 2.11 The Delivery Service domain model"></p><p>配送服务对订单的任何其他属性都不感兴趣.</p><p><code>厨房服务(Kitchen Service)</code>也有一个更简单的订单视图.它的 <code>订单</code> 版本称为票据(Ticket).如图 2.12 所示, 票据只是由一个状态、<code>requestedDeliveryTime</code>、一个 <code>prepareByTime</code> 和一个告诉餐馆准备内容的行项目列表组成.它不关心消费者、支付、配送等等.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.12_The_Kitchen_Service_domain_model.jpg" alt="Figure 2.12 The Kitchen Service domain model"></p><p><code>订单</code> 服务具有订单最复杂的视图, 如图 2.13 所示.尽管它有很多字段和方法, 但仍然比原来的版本简单得多.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第2章-分解策略/Figure_2.13_The_Order_Service_domain_model.jpg" alt="Figure 2.13 The Order Service domain model"></p><p>每个领域模型中的 <code>Order</code> 类代表同一个 <code>Order</code> 业务实体的不同方面.FTGO 应用程序必须在不同服务中的这些不同对象之间保持一致性.例如, 一旦订单服务授权了消费者的信用卡, 它就必须在厨房服务中触发票据的创建.类似地, 如果餐厅通过厨房服务拒绝订单, 则必须在订单服务服务中取消订单, 并将客户记入账单服务中.在第 4 章中, 您将学习如何使用前面提到的事件驱动机制 saga 来维护服务之间的一致性.</p><p>在创建技术挑战的同时, 拥有多个领域模型也会影响用户体验的实现.应用程序必须在用户体验(即它自己的域模型)和每个服务的域模型之间进行转换.例如, 在 FTGO 应用程序中, 显示给消费者的订单状态来自存储在多个服务中的订单信息.这种转换通常由 API 网关处理, 在第 8 章中讨论.尽管存在这些挑战, 但是在定义微服务体系结构时, 确定和消除 god 类是非常重要的.</p><p>现在我们来看看如何定义服务 API.</p><h2 id="定义服务-API"><a href="#定义服务-API" class="headerlink" title="定义服务 API"></a>定义服务 API</h2><p>到目前为止，我们有一个系统操作列表和一个潜在服务列表.下一步是定义每个服务的 API: 其操作和事件.服务 API 操作存在的原因有两个: 一些操作与系统操作相对应.它们由外部客户端调用, 也可能由其他服务调用.其他操作的存在是为了支持服务之间的协作.这些操作仅由其他服务调用.</p><p>服务发布事件主要是为了使其能够与其他服务协作.第 4 章描述了如何使用事件来实现 sagas, 从而维护跨服务的数据一致性.第 7 章讨论了如何使用事件更新支持高效查询的 CQRS 视图.应用程序还可以使用事件通知外部客户端.例如, 它可以使用 WebSockets 向浏览器传递事件.</p><p>定义服务 API 的起点是将每个系统操作映射到服务.然后, 我们决定服务是否需要与其他人协作来实现系统操作.如果需要协作, 那么我们将确定这些其他服务必须提供哪些 API 来支持协作.让我们首先看看如何将系统操作分配给服务.</p><p><strong>将系统操作分配给服务</strong><br>第一步是决定哪个服务是请求的初始入口点.许多系统操作整齐地映射到服务, 但有时映射不太明显.例如, 可以考虑<code>noteUpdatedLocation()</code> 操作, 该操作更新快递位置.一方面, 因为它与快递有关, 所以这个操作应该分配给<code>快递服务(Courier service)</code>.另一方面, <code>配送服务(Delivery Service)</code>需要快递位置.在这种情况下, 将操作分配给需要操作提供的信息的服务是一个更好的选择.在其他情况下, 将操作分配给具有处理操作所需信息的服务可能是有意义的.</p><p>表 2.2 显示了 FTGO 应用程序中的哪些服务负责哪些操作.</p><p><strong>将系统操作映射到 FTGO 应用程序中的服务</strong></p><table><thead><tr><th>服务</th><th>操作</th></tr></thead><tbody><tr><td>消费者服务</td><td>createConsumer()</td></tr><tr><td>订单服务</td><td>createOrder()</td></tr><tr><td>餐厅服务</td><td>findAvailableRestaurants()</td></tr><tr><td>厨房服务</td><td>acceptOrder() <br>  noteOrderReadyForPickup()</td></tr><tr><td>配送服务</td><td>noteUpdatedLocation() <br> noteDeliveryPickedUp() <br> noteDeliveryDelivered()</td></tr></tbody></table><p>将操作分配给服务之后, 下一步是决定服务如何协作以处理每个系统操作.</p><p><strong>确定支持服务之间协作所需的 API</strong><br>有些系统操作完全由一个服务处理.例如, 在 FTGO 应用程序中, <code>消费者服务</code>完全独立地处理 <code>createConsumer()</code> 操作.但是其他系统操作跨越多个服务.例如, 处理其中一个请求所需的数据可能分散在多个服务中.例如, 为了实现 <code>createOrder()</code> 操作, <code>订单服务</code>必须调用以下服务, 以验证其前置条件并使后置条件变为真:</p><ul><li><code>消费者服务</code>-验证消费者是否能够下订单并获得其付款信息.</li><li><code>餐厅服务</code>-确认订单行项目, 确认送货地址/时间在餐厅服务区域内, 验证是否满足订单最低要求, 获取订单行项目价格.</li><li><code>厨房服务</code>-创建<code>票据(Ticket)</code>.</li><li><code>会计服务</code>-授权消费者的信用卡。</li></ul><p>类似地, 为了实现 <code>acceptOrder()</code> 系统操作, <code>厨房服务</code>必须调用<code>配送服务</code>来安排快递员配送订单.表 2.3 显示了服务、修改后的 API 和协作者.为了完全定义服务 API, 您需要分析每个系统操作并确定需要什么协作.</p><p><strong>表 2.3 服务及其修订的 API 和协作者</strong></p><table><thead><tr><th>服务</th><th>操作</th><th>协作者</th></tr></thead><tbody><tr><td>消费者服务</td><td>verifyConsumerDetails()</td><td>-</td></tr><tr><td>订单服务</td><td>createOrder()</td><td>消费服务 verifyConsumerDetails() <br> 餐厅服务 verifyOrderDetails() <br> 厨房服务 createTicket() <br> 会计服务 authorizeCard()</td></tr><tr><td>餐厅服务</td><td>findAvailableRestaurants() <br> verifyOrderDetails()</td><td>- </td></tr><tr><td>厨房服务</td><td>createTicket() <br> acceptOrder() <br> noteOrderReadyForPickup()</td><td>配送服务 scheduleDelivery()</td></tr><tr><td>配送服务</td><td>scheduleDelivery() <br> noteUpdatedLocation() <br> noteDeliveryPickedUp() <br> noteDeliveryDelivered()</td><td>-</td></tr><tr><td>会计服务</td><td>authorizeCard()</td><td>-</td></tr></tbody></table><p>到目前为止, 我们已经标识了每个服务实现的服务和操作.但重要的是要记住, 我们所描绘的架构是非常抽象的.我们没有选择任何特定的 IPC 技术.此外, 尽管术语<code>operation</code> 暗示了某种基于同步请求/响应的 IPC 机制, 但是您将看到异步消息传递扮演了重要角色.在本书中, 我描述了影响这些服务如何协作的架构和设计概念.</p><p>第 3 章描述了特定的 IPC 技术, 包括同步通信机制(如 REST)和使用消息代理的异步消息传递.我将讨论同步通信如何影响可用性，并介绍自包含服务的概念, 该概念不同步调用其他服务.实现自包含服务的一种方法是使用第 7 章介绍的 CQRS 模式.例如, <code>订单服务</code>可以维护<code>餐厅服务</code>拥有的数据的副本, 以便消除同步调用<code>餐厅服务</code>来验证订单的需要.它通过订阅<code>餐厅服务</code>发布的事件来保持副本的最新更新.</p><p>第 4 章介绍了 saga 的概念, 以及如何使用异步消息传递来协调参与该 saga 的服务.除了可靠地更新分散在多个服务中的数据之外, saga 也是实现自包含服务的一种方法.例如, 我描述了如何使用 saga 实现 <code>createOrder()</code> 操作, 该操作使用异步消息传递调用服务, 如消费者服务、厨房服务和会计服务.</p><p>第 8 章描述了 API 网关的概念, 它向外部客户端公开 API.API 网关可以使用 API 组合模式(见第 7 章)实现查询操作, 而不是简单地将其路由到服务.API 网关中的逻辑通过调用多个服务并组合结果来收集查询所需的数据.在这种情况下, 系统操作被分配给 API 网关, 而不是服务.服务需要实现 API 网关所需的查询操作.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>架构决定了应用程序的灵活性, 包括可维护性、可测试性和可部署性, 它们直接影响开发速度.</li><li>微服务架构是一种架构风格, 它使应用程序具有很高的可维护性、可测试性和可部署性.</li><li>微服务架构中的服务是围绕业务关注点(业务功能或子领域)组织的, 而不是围绕技术关注点.</li><li>有两种模式用于分解:<ul><li>业务能力分解, 业务能力分解起源于业务架构</li><li>基于领域驱动设计的概念, 按子域分解</li></ul></li><li>通过应用 DDD 并为每个服务定义一个单独的领域模型, 您可以消除 god 类, 这些类会导致防止分解的复杂依赖关系.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这章包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解软件架构及其重要性&lt;/li&gt;
&lt;li&gt;通过应用按业务能力分解和按子域分解的分解模式, 将应用程序分解为服务&lt;/li&gt;
&lt;li&gt;用来自领域驱动设计(DDD)的有界上下文(bounded context)概念来理清数据并使分解更容易&lt;/
      
    
    </summary>
    
      <category term="微服务" scheme="https://ykgarfield.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Microservice-Patterns(译)" scheme="https://ykgarfield.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Microservice-Patterns-%E8%AF%91/"/>
    
    
      <category term="微服务" scheme="https://ykgarfield.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="微服务模式" scheme="https://ykgarfield.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>第1章-逃离单体噩梦</title>
    <link href="https://ykgarfield.github.io/2019/01/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Microservice-Patterns(%E8%AF%91)/%E7%AC%AC1%E7%AB%A0-%E9%80%83%E7%A6%BB%E5%8D%95%E4%BD%93%E5%99%A9%E6%A2%A6/"/>
    <id>https://ykgarfield.github.io/2019/01/05/微服务/Microservice-Patterns(译)/第1章-逃离单体噩梦/</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2019-02-13T14:43:34.193Z</updated>
    
    <content type="html"><![CDATA[<p>本章包含:</p><ul><li>单体噩梦(monolithic hell)的症状以及如何通过采用微服务架构来逃离它</li><li>微服务架构的本质特征及其优缺点</li><li>微服务是如何支持 DevOps 风格的大型复杂应用程序的开发</li><li>微服务架构模式语言以及为什么要使用它</li></ul><p>那只是周一的午餐时间, 但是 Food to Go(FTGO) 公司的首席技术官 Mary 已经感到沮丧了.她的一天开始得很好.在上一周的一次优秀会议上, 她与其他软件架构师和开发人员一起学习了最新的软件开发技术, 包括持续部署和微服务架构.Mary 还和她以前在北卡罗莱纳A&amp;T州(North Carolina A&amp;T State)的计算机科学同学见面，分享了技术领导战争的故事.这次会议让她感到自己被赋予了权力, 并渴望改进 FTGO 开发软件的方式.</p><p>不幸的是， 这种感觉很快就消失了.她刚回到办公室的第一天早上, 又一次痛苦地与高级工程师和商务人士会面.他们花了两个小时讨论为什么开发团队会错过另一个关键的发布日期.可悲的是, 这种会议在过去几年里越来越普遍.尽管采用了敏捷, 开发的速度却在减慢, 几乎不可能实现业务目标.更糟糕的是, 似乎没有一个简单的解决方案.</p><p> 会议让 Mary 意识到 FTGO 正遭受着 <em>单体噩梦(monolithic hell)</em> 的折磨, 解决之道就是采用微服务架构.但是在会议上描述的微服务架构和相关的最先进的软件开发实践感觉像是一个难以实现的梦想.Mary 不清楚她如何在改善 FTGO 软件开发方式的同时扑灭今天的大火.</p><p>幸运的是, 正如你将在这本书中学到的, 有一个方法.但首先, 让我们看看 FTGO 面临的问题以及它们是如何实现的.</p><h1 id="缓慢地走向单体噩梦"><a href="#缓慢地走向单体噩梦" class="headerlink" title="缓慢地走向单体噩梦"></a>缓慢地走向单体噩梦</h1><p>自 2005 年末推出以来, FTGO 的发展突飞猛进.如今, 它是美国领先的在线食品递送公司之一.该公司甚至计划向海外扩张, 尽管由于在实现必要功能方面的拖延, 这些计划处于危险之中.</p><p>FTGO 应用程序的核心非常简单.消费者使用 FTGO 网站或移动应用程序在当地餐馆下单.FTGO 协调一个运送订单的快递网络.它还负责支付快递员和餐厅的费用.餐厅使用FTGO 网站来编辑菜单和管理订单.该应用程序使用各种 web 服务. 包括用于支付的 Stripe, 用于消息传递的 Twilio 和用于电子邮件的 Amazon Simple Email 服务(SES).</p><p>与许多其他老化的企业应用程序一样, FTGO 应用程序是一个整体, 由单个 Java Web 应用程序存档(WAR)文件组成.多年来, 它已经成为一个庞大而复杂的应用程序.尽管FTGO 开发团队尽了最大的努力, 但它已经成为一个泥球模型的例子(<a href="http://www.laputan.org/mud/" target="_blank" rel="noopener">www.laputan.org/mud/</a>).用这种模式的作者 Foote 和 Yoder 的话来说, 这是一种 “结构松散、杂乱无章、草率、管道胶带和捞砂线、意大利面条式代码丛林”.软件交付的速度已经放缓.更糟糕的是, FTGO 应用程序是使用一些过时的框架编写.FTGO 应用程序显示了单体噩梦的所有症状.</p><p>下一节描述 FTGO 应用程序的架构.然后讨论了为什么单体架构一开始工作得很好.我们将讨论 FTGO 应用程序的架构是如何不适应其发展的, 以及这是如何导致单体噩梦的.</p><h2 id="FTGO-应用程序的架构"><a href="#FTGO-应用程序的架构" class="headerlink" title="FTGO 应用程序的架构"></a>FTGO 应用程序的架构</h2><p>FTGO 是一个典型的企业 Java 应用程序.图 1.1 显示了它的架构.FTGO 应用程序有一个六边形架构, 这种架构风格将在第 2 章中详细描述.在六边形架构中, 应用程序的核心由业务逻辑组成.围绕业务逻辑的是实现 UI 并与外部系统集成的各种适配器.</p><p><img src="https://raw.githubusercontent.com/ykgarfield/my-blog/master/images/%E7%AC%AC1%E7%AB%A0-%E9%80%83%E7%A6%BB%E5%8D%95%E4%BD%93%E5%99%A9%E6%A2%A6/Figure-1.1_The_FTGO_application_has_a_hexagonal_architecture.png" alt="Figure-1.1_The_FTGO_application_has_a_hexagonal_architecture"></p><p>业务逻辑由模块组成, 每个模块都是域对象的集合.这些模块的示例包括<code>订单管理</code>、<code>交付管理</code>、<code>账单</code>和<code>支付</code>.有几个适配器与外部系统交互.一些是<em>入站(inbound)</em>适配器, 它们通过调用业务逻辑(包括 <code>REST API</code> 和 <code>Web UI</code> 适配器)来处理请求.其他的是<em>出站(outbound)</em>适配器, 它使业务逻辑能够访问 MySQL 数据库并调用 Twilio 和 Stripe 等云服务.</p><p>尽管有一个逻辑模块化的架构, 但是 FTGO 应用程序被打包成一个 WAR 文件.该应用程序是广泛使用的<em>单体</em>风格软件架构的一个示例, 这种风格将系统构造为单个可执行或可部署组件.如果 FTGO 应用程序是用 Go 语言(GoLang)编写的, 那么它就是一个可执行文件.应用程序的 Ruby 或 NodeJS 版本将是源代码的单个目录层次结构.单体架构本身并不坏.FTGO 开发人员在为他们的应用程序选择单体架构时做出了一个很好的决定.</p><h2 id="单体架构的好处"><a href="#单体架构的好处" class="headerlink" title="单体架构的好处"></a>单体架构的好处</h2><p>在 FTGO 的早期, 当应用程序相对较小时, 应用程序的单体架构有很多好处:</p><ul><li><em>开发简单</em>-IDEs 和其他的开发工具关注于构建单体应用.</li><li><em>易于对应用程序进行彻底更改</em>-你以更改代码和数据库 schema、构建和部署.</li><li><em>直接进行测试</em>-开发人员编写端到端测试来启动应用程序, 调用 REST API 并使用 Selenium 测试 UI.</li><li><em>直接进行部署</em>—开发人员只需将 WAR 文件复制到安装了 Tomcat 的服务器.</li><li><em>容易扩展</em>-FTGO 在负载均衡器后面运行应用程序的多个实例.</li></ul><p>然而, 随着时间的推移, 开发、测试、部署和扩展变得越来越困难.让我们看看为什么.</p><h2 id="生活在单体噩梦中"><a href="#生活在单体噩梦中" class="headerlink" title="生活在单体噩梦中"></a>生活在单体噩梦中</h2><p>不幸的是, 正如 FTGO 开发人员所发现的, 单体架构有一个巨大的限制.成功的应用程序，如 FTGO 应用程序, 有一种在单体架构上不断扩展的习惯.每一次冲刺, FTGO 开发团队都会实现更多的功能, 这使得代码库越来越大.此外, 随着公司越来越成功, 开发团队的规模也在稳步增长.这不仅提高了代码库的增长率, 还增加了管理开销.</p><p>如图 1.2 所示, 曾经小巧、简单的 FTGO 应用程序多年来已经成长为一个庞然大物.同样, 小型的开发团队现在已经变成了多个 Scrum 团队, 每个团队都在一个特定的功能领域工作.由于它的架构已经过时, FTGO 处于一个单体应用的状态.发展是缓慢而痛苦的.敏捷开发和部署是不可能的.让我们看看为什么会这样.</p><p><img src="https://raw.githubusercontent.com/ykgarfield/my-blog/master/images/%E7%AC%AC1%E7%AB%A0-%E9%80%83%E7%A6%BB%E5%8D%95%E4%BD%93%E5%99%A9%E6%A2%A6/Figure-1.2_A_case_of_monolithic_hell.png" alt="Figure-1.2 A case of monolithic hell"></p><p><strong>复杂性威胁着开发人员</strong></p><p>FTGO 应用程序的一个主要问题是它太复杂了.它太大了, 任何开发人员都无法完全理解.因此, 修复 bug 和正确实现新特性变得非常困难和耗时.最后期限错过了.</p><p>更糟糕的是, 这种压倒性的复杂性往往是螺旋式下降.如果代码库难以理解, 开发人员就不会正确地进行更改.每一次更改都会使代码基逐渐变得更复杂, 更难理解.图 1.1 前面所示的整洁的模块化架构并不反映现实.FTGO 正逐渐变成一个可怕的、难以理解的、巨大的泥球.</p><p>Mary 记得最近参加了一个会议, 她遇到了一个开发人员, 他正在编写一个工具来分析数以百万计的代码行(lines-of-code, LOC)应用程序中数千个 jar 之间的依赖关系.当时, 这个工具似乎是 FTGO 可以使用的.现在她不那么肯定了.Mary 认为更好的方法是迁移到更适合复杂应用程序的架构: 微服务.</p><p><strong>开发缓慢</strong></p><p>FTGO 开发人员发现, 除了必须克服难以克服的复杂性之外, 日常的开发任务也很缓慢.大型应用程序会重载并减慢开发人员的 IDE 速度.构建 FTGO 应用程序需要很长时间.而且, 由于它太大, 应用程序需要很长时间才能启动.因此, 编辑构建-运行-测试循环需要很长时间, 这会严重影响生产率.</p><p><strong>从提交到部署的路径是漫长而艰巨的</strong></p><p>FTGO 应用程序的另一个问题是, 将更改部署到生产环境是一个漫长而痛苦的过程.团队通常每个月部署一次产品更新, 通常是在周五或周六晚上.Mary 一直认为, 软件即服务(SaaS)应用程序的最先进技术是<em>持续部署</em>:每天在工作时间多次将更改部署到生产环境中.显然, 到 2011 年为止, Amazon.com 每 11.6 秒就部署一次更改到生产环境中, 而不会对用户产生任何影响!对于 FTGO 开发者来说, 每月更新一次以上的产品似乎是一个遥远的梦想.而采用连续部署几乎是不可能的.</p><p>FTGO 部分采用了敏捷.工程团队分为小队, 使用两周的冲刺.不幸的是, 从代码完成到在生产环境中运行的过程是漫长而艰辛的.许多开发人员都提交到相同的代码库, 其中一个问题是构建常常处于不可发布的状态.当 FTGO 开发人员试图通过使用特性分支来解决这个问题时.他们的尝试导致了冗长而痛苦的合并.因此, 一旦一个团队完成了冲刺, 随之而来的就是很长一段时间的测试和代码稳定.</p><p>将更改引入到生产中需要很长时间的另一个原因是测试需要很长时间.由于代码库非常复杂, 而且还不清楚更改的影响, 开发人员和持续集成(CI)服务器必须运行整个测试套件.系统的一些部分甚至需要人工测试.诊断和修复测试失败的原因也需要一段时间.因此, 完成一个测试周期需要几天的时间.</p><p><strong>扩展困难</strong></p><p>FTGO 团队在扩展其应用程序方面也存在问题.这是因为不同的应用程序模块有相互冲突的资源需求.例如, 餐馆数据存储在一个大的内存数据库中, 该数据库理想地部署在具有大量内存的服务器上.相反, 图片处理模块是 CPU 密集型的, 最好部署在具有大量 CPU 的服务器上.因为这些模块是同一个应用程序的一部分, 所以 FTGO 必须在服务器配置上妥协.</p><p><strong>交付一个可靠的单体是具有挑战性</strong></p><p>FTGO 应用程序的另一个问题是缺乏可靠性.因此, 经常出现生产中断.它不可靠的一个原因是, 由于应用程序很大, 彻底测试应用程序是很困难的.这种可测试性的缺乏意味着 bug 会进入生产环境.更糟糕的是, 应用程序缺乏<em>故障隔离</em>, 因为所有模块都在同一个进程中运行.每隔一段时间, 一个模块中的一个 bug—例如内存泄漏—就会使得应用程序的所有实例逐个崩溃.FTGO 开发人员不喜欢在半夜被传呼由于生产中断.商人更不喜欢失去收入和信任.</p><p><strong>受困于日益过时的技术栈中</strong></p><p>FTGO 团队体验到的单体噩梦的最后一个方面是, 架构迫使他们使用一个正在变得越来越过时的技术栈.单一架构使得采用新的框架和语言变得困难.重写整个单体应用程序, 使用一种可能更好的新技术, 是非常昂贵和危险的.因此, 开发人员被在项目开始时所做的技术选择卡住了.通常, 他们必须维护使用日益过时的技术栈编写的应用程序.</p><p>Spring 框架在向后兼容的同时继续发展, 因此理论上 FTGO 可以进行升级.不幸的是, FTGO 应用程序使用的框架版本与新版本的 Spring 不兼容.开发团队从来没有时间升级这些框架.因此, 应用程序的主要部分使用越来越过时的框架编写.更重要的是, FTGO 开发人员希望试验像 GoLang 和 NodeJS 这样的非 JVM 语言.遗憾的是, 对于单体应用程序来说, 这是不可能的.</p><h1 id="为什么此书和你相关"><a href="#为什么此书和你相关" class="headerlink" title="为什么此书和你相关"></a>为什么此书和你相关</h1><p>您很可能是开发人员、架构师、CTO 或工程副总裁.您负责的应用程序已经不再适用于单体架构.就像 FTGO 的 Mary 一样, 您在和软件交付做斗争, 想要知道如何逃离单体应用的噩梦.或者, 您可能担心您的组织正在走向单体噩梦, 您想知道如何在为时已晚之前改变方向.如果您需要逃离或避免单体噩梦, 这本书适合你.</p><p>这本书花了很多时间来解释微服务架构的概念.我的目标是让你理解这些概念, 不管你使用什么技术.你所需要的只是熟悉企业应用程序架构和设计的基础知识.特别是, 你需要知道以下几点:</p><ul><li>三层架构</li><li>Web 应用程序设计</li><li>如何使用面向对象设计来开发业务逻辑</li><li>如何使用 RDBMS: SQL 和 ACIS 事务</li><li>如何使用消息代理(message  broker)和 REST API 进行进程间通信</li><li>安全性，包括认证和授权</li></ul><p>本书中的代码示例使用 Java 和 Spring 框架编写.这意味着为了充分利用示例, 您还需要熟悉 Spring 框架.</p><h1 id="你会从书中学到什么"><a href="#你会从书中学到什么" class="headerlink" title="你会从书中学到什么"></a>你会从书中学到什么</h1><p>当你读完这本书的时候, 你会明白下面的内容:</p><ul><li>微服务架构的本质特征, 它的优点和缺点, 以及何时使用</li><li>分布式数据管理模式</li><li>有效的微服务测试策略</li><li>微服务的部署选项</li><li>将单体应用程序重构为微服务架构的策略</li></ul><p>你也可以做到以下几点:</p><ul><li>使用微服务架构模式架构一个应用程序</li><li>开发服务的业务逻辑</li><li>使用 sagas 维护跨服务的数据一致性</li><li>实现跨服务的查询</li><li>有效地测试微服务</li><li>开发安全，可配置和可观察的生产就绪服务</li><li>将现有的单体应用重构为微服务</li></ul><h1 id="微服务架构的救援"><a href="#微服务架构的救援" class="headerlink" title="微服务架构的救援"></a>微服务架构的救援</h1><p>Mary 得出结论, FTGO 必须迁移到微服务架构.</p><p>有趣的是, 软件架构与功能需求几乎没有什么关系.您可以使用任何架构实现一组用例(应用程序的功能需求).事实上, 对于成功的应用程序(如 FTGO 应用程序)来说, 称为泥球是很常见的.</p><p>然而, 架构很重要, 因为它影响所谓的<em>服务质量(quality of service )</em>需求, 也称为<em>非功能性需求(nonfunctional requirements)</em>、<em>质量属性( quality attributes)</em>或<em>质量(ilities)</em>.随着 FTGO 应用程序的发展, 各种质量属性都受到了影响, 最明显的是那些影响软件交付速度的属性:可维护性、可扩展性和可测试性.</p><p>一方面, 一个纪律严明的团队可以放慢其走向单体噩梦的步伐.团队成员可以努力维护他们的应用程序的模块化.他们可以编写全面的自动化测试.另一方面, 他们不能避免在单个单体应用程序上工作的大型团队的问题.它们也无法解决日益过时的技术栈问题.一个团队能做的最好的事情就是推迟不可避免的事情.为了逃离单体应用的噩梦, 他们必须迁移到一个新的架构: 微服务架构.</p><p>如今, 越来越多的人认为, 如果您正在构建一个大型的、复杂的应用程序, 您应该考虑使用微服务架构.但究竟什么是<em>微服务</em>?不幸的是, 这个名字起不到什么作用, 因为它过分强调了大小.微服务架构有许多定义.有些人太过拘泥于字面意思, 声称服务应该是很小的——例如, 100 行代码.另一些人则认为一项服务只需要两周的开发时间.Adrian Cockcroft 以前在 Netflix 工作, 将微服务架构定义为由具有有限上下文的松散耦合元素组成的面向服务的架构.这个定义还不错, 但有点复杂.我们看看能不能做得更好. </p><h2 id="规模立方-Scale-cube-和微服务"><a href="#规模立方-Scale-cube-和微服务" class="headerlink" title="规模立方(Scale cube)和微服务"></a>规模立方(Scale cube)和微服务</h2><p>我对微服务架构的定义受到 Martin Abbott 和 Michael Fisher 的优秀著作《可伸缩性的艺术》(Addison-Wesley, 2015)的启发.本书描述了一个有用的三维可伸缩性模型: <em>规模立方(scale cube)</em>, 如图 1.3 所示.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure-1.3_The_scale_cube.png" alt="Figure-1.3 The scale cube"></p><p>这种模型定义了三种方式来伸缩应用程序: X, Y 和 Z.</p><p><strong>X 轴扩展负载平衡跨越多个相同的实例的请求</strong></p><p>X 轴缩放是扩展单体应用程序的一种常见方法.图 1.4 显示了X 轴缩放的工作原理.在负载均衡器后面运行应用程序的多个实例.负载均衡器在应用程序的 N 个相同实例之间分发请求.这是提高应用程序容量和可用性的好方法.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure-1.4_X-axis_scaling.png" alt="Figure-1.4 X-axis scaling"></p><p><strong>Z 轴缩放基于请求的属性路由请求</strong></p><p>Z 轴扩展同样运行单体应用程序的多个实例, 但与 X 轴扩展不同的是, 每个实例只负责数据的一个子集.图 1.5 显示了Z 轴伸缩的工作原理.位于实例前面的路由器使用请求属性将其路由到适当的实例.例如, 应用程序可以使用 <code>userId</code> 路由请求.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure-1.5_Y-axis_scaling.png" alt="Figure-1.5 Y-axis scaling"></p><p>在本例中, 每个应用程序实例负责一个用户子集.路由器使用请求授权(Authorization)头指制定 <code>userId</code> 选择应用程序的 N 个相同实例中的一个.Z 轴伸缩是扩展应用程序以处理不断增加的事务和数据量的好方法.</p><p><strong>Y 轴伸缩功能将应用程序分解为服务</strong></p><p>X 轴和 Z 轴伸缩提高了应用程序的容量和可用性.但是这两种方法都不能解决增加开发和应用程序复杂性的问题.要解决这些问题, 您需要应用 Y 轴伸缩或功能分解.图 1.6 显示了 Y 轴伸缩的工作方式: 通过将单个应用程序分割成一组服务.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure-1.6_Y-axis_scaling.png" alt="Figure-1.6 Y-axis scaling"></p><p>一个服务是一个微型应用程序, 它实现了狭义的功能, 比如订单管理、客户管理等等.服务使用 X 轴缩放来扩展, 尽管有些服务也可以使用 Z 扩展.例如, 订单服务由一组负载均衡的服务实例组成.</p><p>微服务架构(microservices)的高层定义是一种架构风格, 在功能上将应用程序分解为一组服务.注意, 这个定义没有说明大小.相反, 重要的是每个服务都有一组集中的、有凝聚力的职责.稍后我将在书中讨论这是什么意思.</p><p>现在让我们看看微服务架构是一种怎样的模块化形式.</p><h2 id="微服务作为一种模块化的形式"><a href="#微服务作为一种模块化的形式" class="headerlink" title="微服务作为一种模块化的形式"></a>微服务作为一种模块化的形式</h2><p>在开发大型、复杂的应用程序时, 模块化是必不可少的.像 FTGO 这样的现代应用程序太大, 个人无法开发.它也很复杂, 没发被一个人理解.应用程序必须分解成由不同的人开发和理解的模块.在单体应用程序中, 模块是使用编程语言结构(如 Java 包)和构造构件(如 Java JAR 文件)的组合来定义的.然而, 正如 FTGO 开发人员所发现的, 这种方法在实践中往往不能很好地工作.长寿命的单体应用程序通常会退化为巨大的泥球.</p><p>微服务架构使用服务作为模块化的单元.服务有一个 API, 这是难以违反的不可跨越的边界.不能像使用 Java 包那样绕过 API 访问内部类.因此, 随着时间的推移, 保持应用程序的模块化要容易得多.使用服务作为构建块还有其他好处, 包括能够独立部署和扩展它们.</p><h2 id="每个服务有自己的数据库"><a href="#每个服务有自己的数据库" class="headerlink" title="每个服务有自己的数据库"></a>每个服务有自己的数据库</h2><p>微服务架构的一个关键特征是服务是松散耦合的, 并且仅通过 API 进行通信.实现松耦合的一种方法是每个服务都有自己的数据存储.例如, 在在线商店中, <code>订单服务(Order Service)</code>有一个包含 <code>ORDERS</code> 表的数据库, 而 <code>客户服务(Customer Service)</code>有一个包含 <code>CUSTOMERS</code> 表的数据库.在开发时, 开发人员可以更改服务的schema, 而不必与从事其他服务的开发人员协调.在运行时, 服务彼此隔离-例如, 一个服务永远不会被阻塞, 因为另一个服务持有数据库锁.</p><blockquote><p><strong>别担心: 松散耦合不会让 Larry Ellison(拉里·埃里森)更富有</strong><br>要求每个服务都有自己的数据库并不意味着它有自己的数据库服务器.例如, 您不必在 Oracle RDBMS 许可证上多花 10 倍的钱.第2章深入探讨了这个主题.</p></blockquote><h2 id="FTGO-微服务架构"><a href="#FTGO-微服务架构" class="headerlink" title="FTGO 微服务架构"></a>FTGO 微服务架构</h2><p>现在我们已经定义了微服务架构并描述了它的一些基本特性, 接下来让我们看看如何将其应用到 FTGO 应用程序中.</p><p>本书的剩余部分将深入讨论 FTGO 应用程序的微服务架构.但首先让我们快速看看将 Y 轴缩放应用到这个应用程序意味着什么.如果我们对 FTGO 应用程序应用 Y 轴分解, 就会得到如图 1.7 所示的架构.分解后的应用程序由许多前端和后端服务组成.我们还将应用 X 轴, 可能还有 Z 轴缩放, 以便在运行时每个服务都有多个实例.</p><p>前端服务包括 API 网关和餐馆 Web UI.API 网关扮演着门面的角色, 在第 8 章中有详细描述, 它提供了由消费者和快递人员的移动应用程序使用的 REST API.餐馆 Web UI 实现了餐馆用来管理菜单和处理订单的 Web 界面.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure-1.7_Some_of_the_services_of_the_microservice_architecture.png" alt="Figure-1.7 Some of the services of the microservice architecture"></p><p>许多服务与本章前面描述的模块相对应.不同的是, 每个服务及其 API 都有非常明确的定义.每一个都可以独立开发、测试、部署和扩展.而且, 这种架构在保持模块化方面做得很好.开发人员不能绕过服务的 API 来访问其内部组件.第 13 章描述了如何将现有的单体应用程序转换为微服务.</p><h2 id="微服务架构与-SOA-的比较"><a href="#微服务架构与-SOA-的比较" class="headerlink" title="微服务架构与 SOA 的比较"></a>微服务架构与 SOA 的比较</h2><p>一些批评微服务架构的人声称它并不是什么新东西-它是面向服务的架构(SOA).从高层次来讲, 它们有一些相似之处.SOA 和微服务架构都是将系统构造为一组服务的架构风格.但是, 如表 1.1 所示, 一旦深入研究, 就会发现显著的差异.</p><p><strong>表 1-1 SOA 和微服务对比</strong></p><table><thead><tr><th>–</th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>内部服务通信</td><td>智能管道(Smart pipes), 如企业服务总线(ESB), 使用重量级协议, 如 SOAP 和其他 WS* 标准</td><td>哑管道(Dumb pipes), 如消息代理, 或直接服务对服务通信, 使用轻量级协议, 如 REST 或 gRPC</td></tr><tr><td>数据</td><td>全局数据模型与共享数据库</td><td>每个服务都有数据模型和数据库</td></tr><tr><td>典型的服务</td><td>大型单体应用</td><td>小型服务</td></tr></tbody></table><p>SOA 和微服务架构通常使用不同的技术栈.SOA 应用程序通常使用重量级技术, 如 SOAP 和其他 <code>WS*</code> 标准.他们通常使用 ESB, 一个包含业务和消息处理逻辑的<em>智能管道(Smart pipes)</em>来集成服务.使用微服务架构构建的应用程序倾向于使用轻量级的开源技术.服务通过<em>哑管道(Dumb pipes)</em>进行通信, 比如消息代理或 REST 或 gRPC 之类的轻量级协议.</p><p>SOA 和微服务架构在处理数据的方式上也有所不同.SOA 应用程序通常具有全局数据模型并共享数据库.相反, 正如前面提到的, 在微服务架构中, 每个服务都有自己的数据库.此外, 如将在第 2 章所述的, 通常认为每个服务都有自己的领域模型.</p><p>SOA 和微服务架构之间的另一个关键区别是服务的大小.SOA 通常用于集成大型、复杂、独立的应用程序.尽管微服务架构中的服务并不总是很小, 但它们几乎总是要小得多.因此, SOA 应用程序通常由一些大型服务组成, 而基于微服务的应用程序通常由几十个或数百个较小的服务组成.</p><h1 id="微服务架构的优点和缺点"><a href="#微服务架构的优点和缺点" class="headerlink" title="微服务架构的优点和缺点"></a>微服务架构的优点和缺点</h1><p>让我们先想想优点, 然后再看看缺点.</p><h2 id="微服务架构的优点"><a href="#微服务架构的优点" class="headerlink" title="微服务架构的优点"></a>微服务架构的优点</h2><p>微服务架构有以下的优点:</p><ul><li>它支持大型复杂应用程序的持续交付和部署.</li><li>服务很小, 很容易维护.</li><li>服务独立部署.</li><li>服务独立扩展.</li><li>微服务架构使团队能够自治.</li><li>它允许轻松地试验和采用新技术.</li><li>它具有更好的故障隔离.</li></ul><p>让我们看下每一种优点.</p><p><strong>它支持大型复杂应用程序的持续交付和部署</strong></p><p>微服务架构最重要的优点是它支持大型复杂应用程序的持续交付和部署.正如 1.7 节后面所述的, 持续交付/部署是 DevOps 的一部分, DevOps 是一组用于快速、频繁和可靠交付软件的实践.高性能的 DevOps 组织通常将更改部署到生产环境中而很少出现生产问题.</p><p>有三种方式使微服务架构能够持续交付/部署:</p><ul><li><em>它具有持续交付/部署所需的可测试性</em>-自动化测试是持续交付/部署的关键实践.由于微服务架构中的每个服务都相对较小, 因此自动化测试更容易编写, 执行速度也更快.因此, 应用程序的 bug 会更少.</li><li><em>它具有持续交付/部署所需的可部署性</em>-每个服务都可以独立于其他服务部署.如果负责服务的开发人员需要部署该服务的本地更改, 他们不需要与其他开发人员协调.他们可以部署他们的变更.因此, 更容易将更改频繁地部署到生产环境中.</li><li><em>它使开发团队能够自治和解耦</em>-您可以将工程组织构建为小型(例如, 两个批萨)团队的集合.每个团队单独负责一个或多个相关服务的开发和部署.如图 1.8 所示, 每个团队可以独立于所有其他团队开发、部署和扩展其服务.因此, 开发速度大大提高.</li></ul><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure-1.8_The_microservices-based_FTGO_application_consists_of_a_set_of_loosely_coupled_services.png" alt="Figure-1.8 The microservices-based FTGO application consists of a set of loosely coupled services"></p><p>持续交付和部署的能力有几个商业利益:</p><ul><li>它缩短了进入市场的时间, 从而使业务能够迅速对客户的反馈做出反应.</li><li>它使企业能够提供当今客户所期望的可靠服务.</li><li>员工满意度更高, 因为更多的时间花在交付有价值的功能上, 而不是去救火.</li></ul><p>因此，微服务架构已经成为任何依赖软件技术的业务的关键所在.</p><p><strong>服务很小, 很容易维护</strong></p><p>微服务架构的另一个好处是每个服务都相对较小.对于开发人员来说, 代码更容易理解.小型的代码库不会降低 IDE 的速度, 从而提高开发人员的工作效率.而且, 每个服务的启动速度通常都比大型整体服务快得多, 这也使得开发人员更有效率, 并加快了部署速度.</p><p><strong>服务独立扩展</strong></p><p>微服务加过中的每个服务都可以使用 X 轴克隆和 Z 轴分区独立于其他服务进行伸缩.此外, 每个服务都可以部署在最适合其资源需求的硬件上.这与使用单体架构时非常不同, 在单体架构中, 具有完全不同的资源需求的组件(例如, CPU 密集型组件和内存密集型组件)必须一起部署.</p><p><strong>更好的故障隔离</strong></p><p>微服务架构具有更好的故障隔离.例如, 一个服务中的内存泄漏只影响该服务.其他服务将继续正常处理请求.相比之下, 单体架构中一个行为不好的组件将导致整个系统的崩溃.</p><p><strong>轻松地试验和采用新技术</strong></p><p>最后但并非最不重要的一点是, 微服务架构消除了对技术栈的任何长期承诺.原则上, 在开发新服务时, 开发人员可以自由选择最适合该服务的语言和框架.在许多组织中, 限制选择是有意义的, 但关键是你不受过去决定的约束.</p><p>此外, 因为服务很小, 所以使用更好的语言和技术重写它们变得很实用.如果一项新技术的试验失败了, 你可以放弃这项工作, 而不用让整个项目冒风险.这与使用单体架构时非常不同, 在单体架构中, 最初的技术选择严重限制了将来使用不同语言和框架的能力.</p><h2 id="微服务架构的缺点"><a href="#微服务架构的缺点" class="headerlink" title="微服务架构的缺点"></a>微服务架构的缺点</h2><p>当然, 没有什么技术是银弹, 而且微服务架构有许多明显的缺陷和问题.事实上, 这本书的大部分内容都是关于如何解决这些缺点和问题的.当你读到这些挑战时, 不要担心.在这本书的后面, 我描述了解决这些问题的方法.</p><p>下面是微服务架构的主要缺陷和问题:</p><ul><li>寻找合适的服务集是具有挑战性的</li><li>分布式系统非常复杂， 这使得开发、测试和部署变得非常困难</li><li>部署跨多个服务的特性需要仔细的协调</li><li>决定何时采用微服务架构是很困难的</li></ul><p>让我们依次看下每一个.</p><p><strong>寻找合适的服务集是具有挑战性的</strong></p><p>使用微服务架构的一个挑战是, 没有一个具体的、定义良好的算法来将系统分解为服务.与许多软件开发一样, 这是一门艺术.更糟糕的是, 如果不正确地分解一个系统, 您将构建一个<em>分布式单体系统(distributed monolith)</em>, 这个系统由必须部署在一起的耦合服务组成.分布式单体架构既有单体架构的缺点, 也有微服务架构的缺点.</p><p><strong>分布式系统是复杂的</strong></p><p>使用微服架构的另一个问题是, 开发人员必须处理创建分布式系统的额外复杂性.服务必须使用进程间通信机制.这比简单的方法调用更复杂.此外, 服务必须被设计为能够处理分区故障, 并能处理远程服务不可用或具有高延迟.</p><p>实现跨多个服务的用例需要使用不熟悉的技术.每个服务都有自己的数据库, 这使得实现跨服务的事务和查询成为一项挑战.如第 4 章所述, 基于微服务的应用程序必须使用众所周知的 <em>sagas</em> 来维护服务之间的数据一致性.第 7 章解释了基于微服务的应用程序不能使用简单查询从多个服务检索数据.相反, 它必须使用 API 组合或 CQRS 视图来实现查询.</p><p>IDE 和其他开发工具关注于构建单体应用程序, 而不为开发分布式应用程序提供显式支持.编写涉及多个服务的自动化测试是一项挑战.这些都是特定于微服务架构的问题.因此, 为了成功地使用微服务, 组织的开发人员必须具有复杂的软件开发和交付技能.</p><p>微服务架构还引入了重大的操作复杂性.更多的移动部件-不同类型服务的多个实例-必须在生产中进行管理.要成功部署微服务, 您需要高度自动化.您必须使用以下技术:</p><ul><li>自动部署工具, 比如 Netflix Spinnaker</li><li>一个现成的 PaaS, 比如 Pivotal Cloud Foundry 或 Red Hat OpenShift</li><li>Docker 编排平台, 如 Docker Swarm 或 Kubernetes</li></ul><p>我在第 12 章中更详细地描述部署选项.</p><p><strong>部署跨越多个服务的特性需要仔细的协调</strong></p><p>使用微服务架构的另一个挑战是, 部署跨多个服务的特性需要在不同的开发团队之间进行仔细的协调.您必须创建一个部署计划, 根据服务之间的依赖关系对服务部署进行排序.这与单体架构非常不同, 在单体架构中, 您可以轻松地将更新部署到多个组件上.</p><p><strong>决定何时采用微服务架构是很困难的</strong></p><p>使用微服务架构的另一个问题是决定在应用程序生命周期的哪个点应该使用这个架构.在开发应用程序的第一个版本时, 通常不会遇到架构所要解决的问题.此外, 使用复杂的分布式架构会减慢开发速度.对于初创企业来说, 这可能是一个很大的难题, 其中最大的问题通常是如何快速发展业务模型和相应的应用程序.使用微服务架构使快速迭代变得更加困难.几乎可以肯定的是, 创业应该从单一应用程序开始.</p><p>但是, 稍后, 当问题是如何处理复杂性时, 从功能上将应用程序分解为一组微服务是有意义的.您可能会发现, 由于复杂的依赖关系, 重构很困难.第13章讨论了将单个应用程序重构为微服务的策略.</p><p>正如您所看到的, 微服务架构提供了许多好处, 但也有一些明显的缺点.由于这些问题, 采用微服务架构不应该轻率地进行.但对于复杂的应用程序, 比如面向消费者的web 应用程序或 SaaS 应用程序, 这通常是正确的选择.著名的网站如 eBay(<a href="http://www.slideshare.net/randyshoup/ebay-architecturestriking" target="_blank" rel="noopener">www.slideshare.net/randyshoup/ebay-architecturestriking</a> -balance-between site-stability-features-speed-performance-cost)、Amazon.com、Groupon 和 Gilt 都已经从一个单一的架构发展成为一个微服务架构.</p><p>在使用微服务架构时, 您必须解决许多设计和架构问题.更重要的是, 许多问题都有多种解决方案, 每一个都有不同的权衡.没有一个完美的解决方案.为了帮助指导您的决策, 我创建了微服务架构模式语言.在本书的其余部分中, 当我向您介绍微服务架构时, 我引用了这种模式语言.让我们看看什么是模式语言.以及它为什么有用.</p><h1 id="微服务架构语言"><a href="#微服务架构语言" class="headerlink" title="微服务架构语言"></a>微服务架构语言</h1><p>架构和设计都是关于决策的.您需要决定是单体架构还是微服务架构最适合您的应用程序.在做这些决定时, 你要考虑很多权衡取舍.如果选择了微服务架构, 则需要解决许多问题.</p><p>描述各种架构和设计选项并改进决策制定的一个好方法是使用模式语言.首先让我们了解为什么需要模式和模式语言, 然后我们将介绍微服务架构模式语言.</p><h2 id="微服务架构不是银弹"><a href="#微服务架构不是银弹" class="headerlink" title="微服务架构不是银弹"></a>微服务架构不是银弹</h2><p>早在 1986 年,<em>《人月神话》</em>(Addison-Wesley Professional, 1995 年)的作者 Fred Brooks 说, 在软件工程中, 没有灵丹妙药.这意味着没有任何技术或技巧可以让你的生产力提高十倍.然而几十年后, 开发人员仍然在激烈地争论他们最喜欢的银弹, 他们坚信他们最喜欢的技术将大大提高他们的生产力.</p><p> 很多论据都遵循了 <em>suck/rock 二分法</em>(<a href="http://nealford.com/memeagora/2009/08/05/suck-rock-dichotomy.html)" target="_blank" rel="noopener">http://nealford.com/memeagora/2009/08/05/suck-rock-dichotomy.html)</a>, Neal Ford 创造的一个术语, 它描述了软件世界中的所有东西要么是 suck 的, 要么是 rock 的, 没有中间立场.这些论点都有这样的结构: 如果你做 X，那么小狗狗就会死去，因此你必须做 Y.例如, 同步与反应式编程、面向对象与函数式、Java 与 JavaScript、REST 与消息传递.当然, 现实更加微妙.每一种技术都有其倡导者经常忽视的缺点和局限性.因此, 采用的技术通常遵循 <em>Gartner 技术成熟度曲线</em>(<a href="https://en.wikipedia.org/wiki/Hype_cycle)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hype_cycle)</a>, 其中新兴技术经历五个阶段, 包括过<em>高期望的峰值</em>(它很狂热-rock), 随后是<em>理想幻灭的低谷</em>(它很糟糕-suck), 并以<em>实质生产的高峰期</em>结束(我们现在明白了权衡和何时使用它).</p><blockquote><p>Gartner 技术成熟度曲线中文可参考 <a href="https://baike.baidu.com/item/%E6%8A%80%E6%9C%AF%E6%88%90%E7%86%9F%E5%BA%A6%E6%9B%B2%E7%BA%BF/2551258" target="_blank" rel="noopener">技术成熟度曲线</a></p></blockquote><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/技术成熟度曲线.jpg" alt="技术成熟度曲线"><br>(图片来自 <a href="http://huaban.com/pins/111734468/" target="_blank" rel="noopener">http://huaban.com/pins/111734468/</a>)</p><p>微服务也不能幸免于银弹现象.这个架构是否适合您的应用程序取决于许多因素.因此, 建议始终使用微服务架构是不好的建议, 但建议永远不要使用它同样是不好的建议.和许多事情一样, 这要视情况而定.</p><p>这些关于技术的两极分化和炒作的根本原因是, 人类主要是由他们的情感驱动.乔纳森海特(Jonathan Haidt)在他的优秀著作<em>《正义的心灵: 为什么好人会被政治和宗教分裂》</em>(Vintage 出版社, 2013 年)中，用大象和骑手的比喻来描述人类的心灵是如何运作的.大象代表人类大脑的情感部分.它做了大部分的决定.骑手代表大脑的理性部分.它有时会影响大象, 但主要是为大象的决定提供理由.</p><p>我们-软件开发社区-需要克服我们的情感天性, 找到一种更好的方式来讨论和应用技术.讨论和描述技术的一个好方法是使用模式格式(pattern format), 因为它是客观的.在以模式格式描述技术时, 您必须描述其缺点.让我们看看模式格式.</p><h2 id="模式和模式语言"><a href="#模式和模式语言" class="headerlink" title="模式和模式语言"></a>模式和模式语言</h2><p>模式是对在特定上下文中发生的问题的可重用解决方案.这个想法起源于现实世界的架构, 并被证明在软件架构和设计中是有用的.模式的概念是由现实世界的建筑师 Christopher Alexander 提出.他还创建了模式语言的概念, 这是解决特定领域问题的相关模式的集合.他的书《模式语言:城镇、建筑物、建筑》(牛津大学出版社, 1977 年)描述了一种建筑模式语言, 由 253 种模式组成.这些模式从解决方案到高层次的问题, 比如城市的位置(“取水”), 到低层次的问题, 比如如何设计房间(“每个房间的两面都有灯光”).这些模式中的每一种都通过将范围从城市到窗口的物理对象排列来解决问题.</p><p>Christopher Alexander 的著作启发了软件社区采用模式和模式语言的概念.由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著的《设计模式:可重用面向对象软件的元素》(Addison-Wesley Professional, 1994)是面向对象设计模式的集合.这本书在软件开发人员中普及了模式.自上世纪 90 年代中期以来, 软件开发人员记录了大量的软件模式.<em>软件模式</em>通过定义一组协作软件元素来解决软件架构或设计问题.</p><p>例如, 假设您正在构建一个必须支持各种透支策略的银行应用程序.每项政策都对账户余额和透支账户收取的费用进行了限制.您可以使用策略模式来解决这个问题, 策略模式是经典设计模式书籍中的一个著名模式.该策略模式定义的解决方案由三个部分组成:</p><ul><li>一个策略接口 <code>Overdraft</code> 封装了透支的算法</li><li>一个或多个具体的策略类, 每个特定上下文对应一个</li><li><code>Account</code> 类使用这个算法</li></ul><p>策略模式是面向对象的设计模式, 因此解决方案的元素是类.在本节后面, 我将描述高级设计模式, 其中解决方案由协作服务组成.</p><p>模式之所以有价值, 一个原因是模式必须描述它所应用的上下文.解决方案是特定于特定上下文的, 在其他上下文中可能不能很好地工作, 这种想法是对通常讨论的技术的改进.例如, 对于用户较少的应用程序来说, 以 Netflix 的规模解决这个问题的解决方案可能不是最好的方法.</p><p>然而, 模式的价值远远超过了要求您考虑问题的上下文.它迫使您描述解决方案的其他重要但经常被忽略的方面.一个常用的模式结构包括三个特别有价值的部分:</p><ul><li>约束(forces)</li><li>产生的背景</li><li>相关的模式</li></ul><p>让我们从力开始, 看看每一个.</p><p><strong>约束:解决疑难时必须解决的问题</strong></p><p>模式的约束部分描述了在给定上下文中解决问题时必须解决的约束问题.约束可能会发生冲突, 因此不可能解决所有的冲突.哪种约束更重要取决于环境.你必须优先解决一些问题.例如, 代码必须易于理解并具有良好的性能.用响应式编写的代码比同步代码有更好的性能, 但通常更难于理解.明确列出这些约束是有用的, 因为它清楚地表明哪些问题需要解决.</p><p><strong>产生的背景: 应用模式的后果</strong></p><p>模式产生的背景部分描述了应用模式的后果.它包括三个部分:</p><ul><li><em>优点</em>-模式的优点, 包括已经解决的约束</li><li><em>缺点</em>-模式的缺点, 包括未解决的约束</li><li><em>问题</em>-应用模式引入的新问题</li></ul><p>产生的背景提供了解决方案的更完整和更少偏见的视图, 从而能够做出更好的设计决策.</p><p><strong>相关模式:五种不同类型的关系</strong></p><p>模式的相关模式部分描述了模式和其他模式之间的关系.模式之间有五种关系:</p><ul><li><em>前身(Predecessor)</em>-前身模式是一种激发对这种模式需求的模式.例如, 除了单体架构模式之外, 微服务架构模式是模式语言中其他模式的前身.</li><li><em>后继者(Successor)</em>-解决这个模式引入的问题的模式.例如, 如果应用微服务架构模式, 则必须应用许多后继模式, 包括服务发现模式和断路器模式.</li><li><em>替代模式</em>-为这种模式提供另一种解决方案的模式.例如, 单体架构模式和微服务架构模式是构建应用程序的可替代方法.你选择其中一个.</li><li><em>泛化(Generalization)</em>-一个问题的通用解决方案.例如, 在第 12 章中, 您将了解单主机单服务模式(Single service per host pattern)的不同实现.<br><em>专门化(Specialization)</em>-特定模式的专门化形式.例如, 在第 12 章中, 您将了解将服务作为容器模式部署是单主机单服务的专门化.</li></ul><p>此外, 您可以将处理特定问题区域中的问题的模式组织成组.相关模式的明确描述为如何有效地解决特定问题提供了有价值的指导.图 1.9 显示了如何以可视方式表示模式之间的关系.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure-1.9_The_visual_representation_of_different_types_of_relationships_between_the_patterns.png" alt="Figure-1.9 The visual representation of different types of relationships between the patterns"></p><p>图 1.9 所示的模式之间不同类型的关系表示如下:</p><ul><li>体现了前身-后继者模式的关系</li><li>模式是同一问题的替代解决方案</li><li>表明一个模式是另一个模式的专门化</li><li>适用于特定问题领域的模式</li></ul><p>通过这些关系联系起来的模式集合有时形成所谓的模式语言.模式语言中的模式一起工作以解决特定领域中的问题.特别是, 我已经创建了微服务架构模式语言.它是微服务相关的软件架构设计模式的集合.让我们来看看这种模式语言.</p><h2 id="微服务架构模式概览"><a href="#微服务架构模式概览" class="headerlink" title="微服务架构模式概览"></a>微服务架构模式概览</h2><p>微服务架构模式语言是一组模式, 帮助您使用微服务架构构建应用程序.图 1.10 显示了模式语言的高级结构.模式语言首先帮助您决定是否使用微服务架构.它描述了单体架构和微服务架构, 以及它们的优缺点.然后, 如果微服务架构非常适合您的应用程序, 那么模式语言可以通过解决各种架构和设计问题来帮助您有效地使用它.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure-1.10_A_high-level_view_of_the_Microservice_architecture_pattern_language.png" alt="Figure-1.10 A high-level view of the Microservice architecture pattern language"></p><p>模式语言由几组模式组成.在图 1.10 的左边是应用程序架构模式组、单体架构模式和微服务架构模式.这些是我们在本章中讨论过的模式.模式语言的其余部分由一组模式组成, 这些模式是使用微服务架构模式引入的问题的解决方案.</p><p>模式分为三层:</p><ul><li><em>基础架构模式</em>-它们解决了开发之外的大部分基础设施问题.</li><li><em>应用程序基础架构模式</em>-这些都是影响开发的基础设施问题.</li><li><em>应用程序模式</em>-解决了开发者面对的问题.</li></ul><p>这些模式是根据它们解决的问题分组在一起的.让我们来看看主要的模式组.</p><p><strong>将应用程序分解为服务的模式</strong></p><p>决定如何将系统分解为一组服务在很大程度上是一门艺术, 但是有许多策略可以提供帮助.图 1.11 中显示的两个分解模式是您可以用来定义应用程序架构的不同策略.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure_1.11_There_are_two_decomposition_patterns_Decompose_by_business_capability.jpg" alt="Figure 1.11 There are two decomposition patterns Decompose by business capability"></p><p>第 2 章详细描述了这些模式.</p><p><strong>通信模式</strong></p><p>使用微服务架构构建的应用程序是一个分布式系统.因此, 进程间通信(IPC)是微服务架构的重要组成部分.关于您的服务如何彼此通信以及如何与外部世界通信, 您必须作出各种架构和设计决策.图 1.12 为通信模式, 分为五组:</p><ul><li><em>通信方式</em>-应该使用什么样的 IPC 机制?</li><li><em>发现(Discovery)</em>-服务的客户端如何确定服务实例的 IP 地址, 以便比如发出 HTTP 请求?</li><li><em>可靠性</em>-您如何确保服务之间的通信是可靠的, 即使服务不可用?</li><li><em>事务性消息</em>-如何将消息的发送和事件的发布与更新业务数据的数据库事务集成起来?</li><li><em>外部 API</em>-应用程序的客户端如何与服务通信?</li></ul><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure_1.12_The_five_groups_of_communication_patterns.jpg" alt="Figure 1.12 The five groups of communication patterns"></p><p>第 3 章介绍了前四组模式:通信方式、发现、可靠性和事务消息.第 8 章介绍了外部 API 模式.</p><p><strong>用于实现事务管理的数据一致性模式</strong></p><p>如前所述, 为了确保松耦合, 每个服务都有自己的数据库.不幸的是, 每个服务都有一个数据库会带来一些重要的问题.我在第 4 章中描述了使用分布式事务(2PC)的传统方法对于现代应用程序来说不是一个可行的选择.相反, 应用程序需要使用 Saga 模式来维护数据一致性.图 1.13 显示了与数据相关的模式.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure_1.13_use_the_Saga_pattern_to_maintain_data_consistency_across_services.jpg" alt="Figure 1.13 use the Saga pattern to maintain data consistency across services"></p><p> 第 4、5、6 章详细地描述了这些模式.</p><p> <strong>用于在微服务架构中查询数据的模式</strong></p><p>每个服务使用数据库的另一个问题是, 一些查询需要 join 多个服务拥有的数据.服务的数据只能通过其 API 访问, 因此不能对其数据库使用分布式查询.图 1.14 显示了一些用于实现查询的模式.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure_1.14_use_one_of_the_querying_patterns_to_retrieve_data_scattered_across_multiple_services.jpg" alt="Figure 1.14 use one of the querying patterns to retrieve data scattered across multiple services"></p><p>有时您可以使用 API 组合模式, 它调用一个或多个服务的 API 并聚合结果.其他时候, 您必须使用命令查询责任隔离(CQRS)模式, 该模式维护一个或多个更容易查询的数据副本.第 7 章介绍了实现查询的不同方法.</p><p><strong>服务部署模式</strong></p><p>部署单个应用程序并不总是容易的, 但是从某种意义上说, 部署单个应用程序非常简单.您必须在负载均衡器后面运行应用程序的多个实例.</p><p>相比之下, 部署基于微服务的应用程序要复杂得多.可能有数十或数百个服务是用各种语言和框架编写的.还有许多活动部件需要管理.图 1.15 显示了部署模式.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure_1.15_Several_patterns_for_deploying_microservices.jpg" alt="Figure 1.15 Several patterns for deploying microservices"></p><p>传统的, 通常是手工的, 以特定于语言的打包格式部署应用程序的方式, 例如 WAR 文件, 不能扩展到支持微服务架构.您需要高度自动化的部署基础设施.理想情况下, 您应该使用一个部署平台, 为开发人员提供一个简单的 UI(命令行或 GUI)来部署和管理他们的服务.部署平台通常基于虚拟机、容器或无服务器技术.第 12 章介绍了不同的部署选项.</p><p><strong>可观察性模式提供了对应用程序行为的洞察</strong></p><p>操作应用程序的一个关键部分是了解其运行时行为, 并对失败请求和高延迟等问题进行故障排除.虽然理解和排除单个应用程序的故障并不总是容易的, 但是它有助于以简单、直接的方式处理请求.每个传入的请求都被负载均衡到一个特定的应用程序实例, 该实例对数据库进行一些调用并返回一个响应.例如, 如果需要了解如何处理某个特定请求, 可以查看处理该请求的应用程序实例的日志文件.</p><p>相比之下, 理解和诊断微服务架构中的问题要复杂得多.在最终将响应返回到客户端之前, 请求可以在多个服务之间跳转.因此, 没有一个日志文件可以检索.同样, 由于存在多个疑点, 延迟问题更难以诊断.</p><p>您可以使用以下模式来设计可观察的服务:</p><ul><li><em>健康检查 API</em>-暴露返回服务健康状态的端点.</li><li><em>日志聚合</em>-日志服务活动, 并将日志写入中央日志服务器, 该服务器提供搜索和警报功能.</li><li><em>分布式跟踪</em>-为每个外部请求分配一个唯一的 ID, 并在它们在服务之间流动时跟踪请求.</li><li><em>异常跟踪</em>-报告异常跟踪服务的异常, 该服务删除重复的异常, 提醒开发人员, 并跟踪每个异常的解决方案.</li><li><em>应用程序度量</em>—维护度量, 例如计数器和度量, 并将它们暴露给度量服务器.</li><li><em>审计日志</em>-记录用户行为.</li></ul><p>第 11 章详细描述了这些模式.</p><p><strong>用于服务自动化测试的模式</strong></p><p>微服务架构使单个服务更容易测试, 因为它们比单体应用程序小得多.但是, 与此同时, 重要的是测试不同的服务在一起工作, 同时避免使用复杂、缓慢和脆弱的端到端测试, 这些测试将多个服务一起测试.以下是通过隔离测试服务简化测试的模式:</p><ul><li><em>消费者驱动的契约测试(Consumer-driven contract test)</em>-验证服务是否满足其客户端的期望.</li><li><em>消费者端契约测试(Consumer-side contract test)</em>-验证服务的客户端可以与服务通信.</li><li><em>服务组件测试</em>-隔离测试服务.</li></ul><p>第 9 章和第 10 章将详细地描述这些测试模式.</p><p><strong>处理横切关注点的模式</strong></p><p>在微服务架构中, 每个服务都必须实现许多关注点, 包括可观察性模式和发现模式.它还必须实现外部化配置模式, 该模式在运行时向服务提供诸如数据库凭据之类的配置参数.在开发新服务时, 从头开始重新实现这些关注点将花费大量时间.更好的方法是应用微服务机箱模式(Microservice Chassis pattern), 并在处理这些问题的框架之上构建服务.第 11 章更详细地描述了这些模式.</p><p><strong>安全模式</strong></p><p>在微服务架构中, 用户通常通过 API 网关进行身份验证.然后, 它必须将关于用户的信息(如标识和角色)传递给它调用的服务.一种常见的解决方案是应用访问令牌(token)模式.API 网关将访问 token, 例如 JWT(JSON Web Token)传递给服务, 服务可以验证令牌并获取关于用户的信息.第 11 章更详细地讨论了访问 token 模式.</p><p>毫不奇怪, 微服务架构模式语言中的模式关注于解决架构和设计问题.为了成功地开发软件, 您当然需要正确的架构, 但这不是唯一需要考虑的问题.您还必须考虑流程和组织.</p><h1 id="超越微观服务-流程与组织"><a href="#超越微观服务-流程与组织" class="headerlink" title="超越微观服务: 流程与组织"></a>超越微观服务: 流程与组织</h1><p>对于大型、复杂的应用程序, 微服务架构通常是最佳选择.但是除了拥有正确的架构之外, 成功的软件开发还需要您拥有组织、开发和交付流程.图 1.16 显示了流程、组织和架构之间的关系.</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/第1章-逃离单体噩梦/Figure_1.16_the_relationships_between_process_and_organization_and_architecture.jpg" alt="Figure 1.16 the relationships between process and organization and architecture"></p><p>我已经描述了微服务架构.让我们看看组织和流程.</p><h2 id="软件开发和交付组织"><a href="#软件开发和交付组织" class="headerlink" title="软件开发和交付组织"></a>软件开发和交付组织</h2><p>成功必然意味着工程团队将成长.一方面, 这是一件好事, 因为更多的开发人员可以完成更多的工作.大型团队的问题是, 正如 Fred Brooks 在《人月神话》中所写的, 规模为 N 的团队的沟通开销为 O(N ^ 2).如果团队太大, 由于沟通开销, 它将变得低效.举个例子, 想象一下, 每天和 20 个人一起做一次站立会议.</p><p>解决方案是将一个大型单一团队重构为一个团队的团队.每个小组人数不多, 不超过 8-12 人.它有一个明确定义的面向业务的任务: 开发并可能操作一个或多个服务, 这些服务实现了一个特性或业务功能.团队是跨功能的, 可以开发、测试和部署其服务, 而不必经常与其他团队进行通信或协调.</p><blockquote><p>反向康威操纵(reverse Conway maneuver)<br>为了在使用微服务架构时有效地交付软件, 您需要考虑 Conway 定律(<a href="https://en.wikipedia.org/wiki/Conway%27s_law)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Conway%27s_law)</a>, 声明如下:<br>设计系统的组织…被限制生产这些组织的通信结构的副本的设计.<br>–Melvin Conway<br>换句话说, 应用程序的架构反映了开发它的组织的结构.因此, 很重要的一点是反向应用 Conway 法则(<a href="http://www.thoughtworks.com/radar/techniques/inverse-conway-maneuver)" target="_blank" rel="noopener">www.thoughtworks.com/radar/techniques/inverse-conway-maneuver)</a>, 并设计您的组织, 使其结构反映您的微服务架构.通过这样做, 您可以确保开发团队与服务一样松耦合.</p></blockquote><p>多个团队的速度明显高于单个大团队的速度.正如前面 1.5.1 节所述, 微服务架构在使团队能够自治方面扮演着关键角色.每个团队可以在不与其他团队协调的情况下开发、部署和扩展其服务.此外, 当服务不符合 SLA 时, 很清楚应该联系谁.</p><p>更重要的是, 开发组织的可伸缩性更强.您可以通过添加团队来发展组织.如果一个团队变得太大, 您可以将其与其关联的服务或服务分开.因为团队是松耦合的, 所以可以避免大型团队的通信开销.因此, 您可以在不影响生产力的情况下增加人员.</p><h2 id="软件开发和交付流程"><a href="#软件开发和交付流程" class="headerlink" title="软件开发和交付流程"></a>软件开发和交付流程</h2><p>使用带有瀑布式开发流程的微服务架构就像驾驶一辆马拉的法拉利-您浪费了使用微服务的大部分好处.如果您希望使用微服务架构开发应用程序, 那么采用敏捷开发和部署实践, 如 Scrum 或 Kanban(看板)是非常重要的.更好的是, 您应该实践持续交付/部署, 这是 DevOps 的一部分.</p><p>Jez Humble(<a href="https://continuousdelivery.com/)对持续交付的定义如下" target="_blank" rel="noopener">https://continuousdelivery.com/)对持续交付的定义如下</a>:</p><blockquote><p><em>持续交付是将所有类型的更改, 包括新特性、配置更改、bug 修复和试验, 安全且快速地以可持续的方式交付到生产或用户手中的能力.</em></p></blockquote><p>持续交付的一个关键特征是软件总是可发布的.它依赖于高度自动化, 包括自动化测试.持续部署在自动将可发布代码部署到生产环境中的实践中, 进一步实现了持续交付.执行连续部署的高性能组织每天将多次部署到生产环境中, 生产中断的情况要少得多, 并且能够从发生的任何中断中快速恢复(<a href="https://puppet.com/resources/whitepaper/state-of-devops-report).正如前面" target="_blank" rel="noopener">https://puppet.com/resources/whitepaper/state-of-devops-report).正如前面</a> 1.5.1 节所述, 微服务架构直接支持持续交付/部署.</p><blockquote><p><strong>快速行动而不破坏事物</strong><br>持续交付/部署(以及更一般的 DevOps)的目标是快速而可靠地交付软件.评估软件开发的四个有用指标如下:</p><ul><li><em>部署频率</em>-软件部署到生产环境中的频率</li><li><em>交付周期</em>-从开发人员签入变更到部署变更的时间</li><li><em>平均恢复时间</em>-从生产问题中恢复的时间</li><li><em>更改故障率</em>-</li></ul><p>在传统的组织中, 部署频率较低, 交付时间较长.压力重重的开发人员和操作人员通常会熬夜, 在维护窗口期间解决最后一分钟出现的问题.相反, DevOps 组织频繁地发布软件, 通常是每天多次, 生产问题要少得多.例如, 亚马逊(Amazon)在 2014 年每 11.6 秒将变更部署到生产中(<a href="http://www.youtube.com/watch?v=dxk8b9rSKOo)" target="_blank" rel="noopener">http://www.youtube.com/watch?v=dxk8b9rSKOo)</a>, 而 Netflix 的一个软件组件交付时间为 16 分钟(<a href="https://medium.com/netflix-techblog/how-we-build-code-at-netflix-c5d9bd727f15)" target="_blank" rel="noopener">https://medium.com/netflix-techblog/how-we-build-code-at-netflix-c5d9bd727f15)</a>.</p></blockquote><p><strong>采用微服务的人性化方面</strong></p><p>采用微服务架构将改变您的架构、组织和开发流程.但最终, 它改变了人们的工作环境, 正如前面提到的, 这些人是情绪化的生物.如果被忽视, 他们的情绪可能会让微服务的采用变得崎岖不平.Mary 和其他 FTGO 领导人将努力改变 FTGO 开发软件的方式.</p><p>威廉和苏珊•布里吉斯合著的畅销书《过渡管理》(Da Capo life Books, 2017,<a href="https://wmbridges.com/books)介绍了过渡的概念" target="_blank" rel="noopener">https://wmbridges.com/books)介绍了过渡的概念</a>, 即人们如何在情绪上对变化做出反应的过程.它描述了一个三阶段转换模型:</p><ol><li><p><em>结束, 失败, 和放手</em>-当人们面对迫使他们走出舒适区的变化时, 情绪波动和抗拒的时期.他们经常为失去了旧的做事方式而悲伤.例如, 当人们重新组织成跨职能的团队时, 他们会想念以前的队友.类似地, 拥有全局数据模型的数据建模组将受到每个服务拥有自己的数据模型的想法的威胁.</p></li><li><p><em>中立区</em>-介于新旧做事方式之间的中间阶段, 人们经常感到困惑.他们经常努力学习新的做事方法.</p></li><li><p><em>新的开始</em>-最后一个阶段, 人们热情地接受新的做事方式, 并开始体验其中的好处.</p></li></ol><p>本书描述了如何最好地管理产品化的每个阶段, 并增加成功实现变更的可能性.FTGO 无疑正遭受着 “单体的噩梦”, 需要迁移到微服务架构.它还必须更改其组织和开发流程.然而, FTGO 要想成功实现这一点, 就必须考虑到转型模式, 并考虑人们的情绪.</p><p>在下一章中, 您将了解软件架构的目标以及如何将应用程序分解为服务.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>单体架构模式将应用程序构建为单个可部署单元.</li><li>微服架构模式将系统分解为一组独立部署的服务, 每个服务都有自己的数据库.</li><li>对于简单的应用程序, 单体架构是一个不错的选择, 但是对于大型复杂的应用程序, 微服务架构通常是一个更好的选择.</li><li>微服务架构通过允许小型、自治的团队并行工作来加速软件开发的速度.</li><li>微服务架构并不是万能的-它有很多明显的缺点, 包括复杂性.</li><li>微服务架构模式语言是帮助您使用微服务架构构建应用程序的模式集合.它帮助您决定是否使用微服务架构, 如果选择微服务架构, 模式语言将帮助您有效地应用它.</li><li>您需要的不仅仅是微服务架构来加速软件交付.成功的软件开发还需要 DevOps 和小型的、自治的团队.</li><li>不要忘记采用微服务的人性化一面.为了成功地过渡到微服务架构, 您需要考虑员工的情绪.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单体噩梦(monolithic hell)的症状以及如何通过采用微服务架构来逃离它&lt;/li&gt;
&lt;li&gt;微服务架构的本质特征及其优缺点&lt;/li&gt;
&lt;li&gt;微服务是如何支持 DevOps 风格的大型复杂应用程序的开发&lt;/li&gt;
&lt;li&gt;微服
      
    
    </summary>
    
      <category term="微服务" scheme="https://ykgarfield.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Microservice-Patterns(译)" scheme="https://ykgarfield.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Microservice-Patterns-%E8%AF%91/"/>
    
    
      <category term="微服务" scheme="https://ykgarfield.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="微服务模式" scheme="https://ykgarfield.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swagger2Markup bug-生成的 html 文档有问题当 ApiModel value 包含斜线</title>
    <link href="https://ykgarfield.github.io/2019/01/01/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/swagger/Swagger2Markup%20bug-%E7%94%9F%E6%88%90%E7%9A%84%20html%20%E6%96%87%E6%A1%A3%E6%9C%89%E9%97%AE%E9%A2%98%E5%BD%93%20ApiModel%20value%20%E5%8C%85%E5%90%AB%E6%96%9C%E7%BA%BF/"/>
    <id>https://ykgarfield.github.io/2019/01/01/文档工具/swagger/Swagger2Markup bug-生成的 html 文档有问题当 ApiModel value 包含斜线/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-01-02T01:58:57.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h1><p>此问题的由来是因为某天看用 <code>asciidoctor-maven-plugin</code> 生成的 swagger html 文档时, 发现有个链接没法跳转到指定的 header.如下图所示:</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/Swagger2Markup_bug-生成的_html_文档有问题当_ApiModel_value_包含斜线/link-can-not-jump.jpg" alt="link-can-not-jump"></p><p>经过排查发现是因为 <code>ApiModel</code> 的 <code>value</code> 包含 <code>/</code> 时会出现问题.以上面的问题为例, 写了一个简单的示例, 如下:</p><p><code>Controller</code> 有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value= <span class="string">"..."</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ApiOperation</span>(value=<span class="string">"..."</span>, notes=<span class="string">"..."</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse <span class="title">createOrder</span><span class="params">(@Valid @RequestBody Order request, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Order</code> 类定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有斜线 /</span></span><br><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"order/create_order"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h1><p>首先查看生成的 html 文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 跳转链接的 ID 是 _create_order</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;#_create_order&quot;&gt;create_order&lt;/a&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">// ID 是 _order_create_order, 而不是 _create_order</span><br><span class="line">&lt;h3 id=&quot;_order_create_order&quot;&gt;order/create_order&lt;/h3&gt;</span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/Swagger2Markup_bug-生成的_html_文档有问题当_ApiModel_value_包含斜线/html-link-can-not-jump-to-header.jpg" alt="link-can-not-jump-to-header"></p><p>进一步排查生成的 <code>.adoc</code> 文件.在 <code>paths.adoc</code>、<code>definitions.adoc</code> 文件中搜索 <code>create_order</code> 相关的信息.</p><p><code>paths.adoc</code> 内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==== Parameters</span><br><span class="line"></span><br><span class="line">[options=&quot;header&quot;, cols=&quot;.^2a,.^3a,.^9a,.^4a&quot;]</span><br><span class="line">|===</span><br><span class="line">|Type|Name|Description|Schema</span><br><span class="line">|**Body**|**request** +</span><br><span class="line">__required__|request|&lt;&lt;_create_order,create_order&gt;&gt;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure><p><code>definitions.adoc</code> 内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[_order_create_order]]</span><br><span class="line">=== order/create_order</span><br></pre></td></tr></table></figure><p>很明显, 这两个 ID 是不一样的.就导致了生成的 html 文档也有问题.</p><p>这会导致如下两个问题:</p><ul><li>链接无法跳转到指定的 header</li><li>请求/响应示例无法生成</li></ul><h1 id="错误原因分析"><a href="#错误原因分析" class="headerlink" title="错误原因分析"></a>错误原因分析</h1><p>针对上面的两个问题, 分别做下错误原因分析:</p><ul><li><p>链接无法跳转到指定的 header:  <code>GenericRef</code> 类有两个属性, <code>ref</code> 和 <code>simpleRef</code>.以上面的例子为例(<code>order/create_order</code>), <code>ref</code> 是 <code>#/definitions/order/create_order</code>, <code>simpleRef</code> 是 <code>create_order</code>.<code>simpleRef</code> 不包含 <code>order</code> 前缀.所以在生成链接 id 的时候, 可能是一个使用了 <code>simpleRef</code>, 另外一个使用了 <code>ref</code>, 所以应该统一使用其中一个.</p></li><li><p>请求/响应示例无法生成: <code>Swagger#getDefinitions()</code> 方法返回的是 <code>Map&lt;String, Model&gt;</code>, 这个 map 里面包含了 <code>/order/create_order</code>, 但是不包含 <code>create_order</code>, 所以当生成示例的时候, 可能是使用的 <code>simpleRef</code> 从 map 中获取 <code>Model</code> 对象(此时肯定获取不到).如果使用 <code>ref</code>(去除 <code>#/definitions/</code> 前缀)可以从 map 中获取 <code>Model</code> 对象, 所以应该先使用 <code>simpleRef</code>, 如果获取不到 <code>Model</code>, 再使用 <code>ref</code>.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;错误描述&quot;&gt;&lt;a href=&quot;#错误描述&quot; class=&quot;headerlink&quot; title=&quot;错误描述&quot;&gt;&lt;/a&gt;错误描述&lt;/h1&gt;&lt;p&gt;此问题的由来是因为某天看用 &lt;code&gt;asciidoctor-maven-plugin&lt;/code&gt; 生成的 swagge
      
    
    </summary>
    
      <category term="文档工具" scheme="https://ykgarfield.github.io/categories/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
    
      <category term="swagger" scheme="https://ykgarfield.github.io/categories/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/swagger/"/>
    
    
      <category term="swagger" scheme="https://ykgarfield.github.io/tags/swagger/"/>
    
      <category term="swagger bug" scheme="https://ykgarfield.github.io/tags/swagger-bug/"/>
    
  </entry>
  
  <entry>
    <title>Swagger bug-当 http 请求方法是 get 时 Operation.getConsumes() 不应该返回 application/json</title>
    <link href="https://ykgarfield.github.io/2018/12/25/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/swagger/Swagger-bug-%E5%BD%93-http-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%98%AF-get-%E6%97%B6-Operation.getConsumes()-%E4%B8%8D%E5%BA%94%E8%AF%A5%E8%BF%94%E5%9B%9E-application-json/"/>
    <id>https://ykgarfield.github.io/2018/12/25/文档工具/swagger/Swagger-bug-当-http-请求方法是-get-时-Operation.getConsumes()-不应该返回-application-json/</id>
    <published>2018-12-24T16:00:00.000Z</published>
    <updated>2018-12-28T05:32:17.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h1><p>相关的 issue 可见: <a href="https://github.com/springfox/springfox/issues/2815" target="_blank" rel="noopener">https://github.com/springfox/springfox/issues/2815</a></p><p>最近在用 swagger lib 的时候发现一个问题, 就是当 HTTP 请求方法是 <code>GET</code>  时候, 返回的 <code>consume</code> 是 <code>application/json</code>, 感觉有些不对劲,  于是乎就做了如下的实验:</p><p>比如有如下一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Api</span>(value =<span class="string">"SwaggerTestService"</span>, tags = <span class="string">"SwaggerTest"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value= <span class="string">"/SwaggerTest/getMethodTest"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"(SwaggerTestService) getMethodTest"</span>, notes=<span class="string">"(SwaggerTestService) getMethodTest"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">getMethodTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问 <code>/v2/api-docs</code> 的时候返回的信息如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"/SwaggerTest/getMethodTest": &#123;</span><br><span class="line">"get": &#123;</span><br><span class="line">"tags": [</span><br><span class="line"><span class="string">"SwaggerTest"</span></span><br><span class="line">],</span><br><span class="line">"summary": "(SwaggerTestService) getMethodTest",</span><br><span class="line">"description": "(SwaggerTestService) getMethodTest",</span><br><span class="line">"consumes": [</span><br><span class="line"><span class="string">"application/json"</span></span><br><span class="line">],</span><br><span class="line">"produces": [</span><br><span class="line"><span class="string">"*/*"</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这里 <code>consumes</code> 返回的是 <code>application/json</code>, 稍微思考下, 会发现其实是不太对的.其实这就意味着 GET 请求的 <code>Content-Type</code> 是  <code>application/json</code>, 但是 HTTP GET 请求怎么会是 <code>application/json</code> 呢? 显然是不对的.相关的 GET 请求是否需要 <code>Content-Type</code> 讨论可见: <a href="https://stackoverflow.com/questions/5661596/do-i-need-a-content-type-for-http-get-requests" target="_blank" rel="noopener">https://stackoverflow.com/questions/5661596/do-i-need-a-content-type-for-http-get-requests</a>, 从中我们可以看出, 只有 <code>POST</code> 和 <code>PUT</code> 需要请求的 <code>Content-Type</code>.</p><p>因为是使用 swagger lib 相关 API 的时候发现的问题, 所以进一步发现是因为 <code>io.swagger.models.Operation#getConsumes()</code> 的返回值有问题.所以在我们使用此 API 的时候, 需要注意, 如果是 <code>GET</code> 请求, 那么是可以忽略此方法的返回值的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class=&quot;headerlink&quot; title=&quot;问题由来&quot;&gt;&lt;/a&gt;问题由来&lt;/h1&gt;&lt;p&gt;相关的 issue 可见: &lt;a href=&quot;https://github.com/springfox/springfox/
      
    
    </summary>
    
      <category term="文档工具" scheme="https://ykgarfield.github.io/categories/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
    
      <category term="swagger" scheme="https://ykgarfield.github.io/categories/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/swagger/"/>
    
    
      <category term="swagger" scheme="https://ykgarfield.github.io/tags/swagger/"/>
    
      <category term="swagger bug" scheme="https://ykgarfield.github.io/tags/swagger-bug/"/>
    
  </entry>
  
  <entry>
    <title>confluence-如何通过程序在 confluence 中创建 markdown 文档</title>
    <link href="https://ykgarfield.github.io/2018/12/23/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/confluence/confluence-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E5%9C%A8-confluence-%E4%B8%AD%E5%88%9B%E5%BB%BA-markdown-%E6%96%87%E6%A1%A3/"/>
    <id>https://ykgarfield.github.io/2018/12/23/文档工具/confluence/confluence-如何通过程序在-confluence-中创建-markdown-文档/</id>
    <published>2018-12-22T16:00:00.000Z</published>
    <updated>2018-12-28T07:59:27.701Z</updated>
    
    <content type="html"><![CDATA[<p>在 confluence 中创建 markdown 文档, 首先需要安装相关的 markdown 插件.既有免费的, 也有付费的.经过试用付费的 markdown 插件, 和免费的对比一下, 发现大部分 markdown 相关的功能都基本一致.付费的提供了一些额外的特性, 比如: 允许使用 html 标签、可选择渲染表格的样式等, 另外就是提供了一个很方便的功能就是可以直接将 markdown 文件上传为附件, 并用此插件插入附件 markdown 文档.而且渲染出来的表格样式比免费的要美观很多.免费的 markdown 插件渲染出来的表格样式实在有点不忍直视, 比较丑陋.</p><p>另外, 无论是免费的还是付费的 markdown 插件都是不支持生成目录语法.大多数平台和 markdown 编辑器可以通过扩展的 <code>[toc]</code> 语法来实现生成目录.在 confluence  中需要插入目录宏, 而且还是可以定义展示的层级, 这个特性还是比较有用的.</p><p>不过为了节约成本, 我们当然还是优先选择免费的.通过人工操作, 写入 markdown 文档是很简单的, 但是怎么通过程序自动的在 confluence 中创建 markdown 文档呢? 目前也没有现成的 API 可以实现.不过通过人工操作并进行抓包, 我们发现可以利用以下几个 API 来实现此功能.这里将插入目录宏(Table of Contents)的操作一起加上.</p><ul><li>插入目录宏: 发起 <code>/rest/tinymce/1/macro/placeholder</code> 请求.</li><li>目录宏 draft: 发起 <code>/rest/tinymce/1/drafts</code> 请求.</li><li>插入 markdown 宏: 还是发起 <code>/rest/tinymce/1/macro/placeholder</code> 请求.</li><li>更新文档(draft status): 发起 <code>/rest/api/content/{id}?status=draft</code> 请求</li></ul><p>下面具体的来说明上面的几个步骤.</p><h2 id="插入目录宏"><a href="#插入目录宏" class="headerlink" title="插入目录宏"></a>插入目录宏</h2><p>发起 <code>/rest/tinymce/1/macro/placeholder</code> 请求.请求的示例如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"contentId"</span>:<span class="string">"6488066"</span>,</span><br><span class="line">    <span class="attr">"macro"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"toc"</span>,</span><br><span class="line">        <span class="attr">"params"</span>:&#123;</span><br><span class="line">            <span class="attr">"maxLevel"</span>:<span class="string">"2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"body"</span>:<span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到, <code>contentId</code> 也就是 page 的 ID, <code>name</code> 固定为 <code>toc</code>, <code>maxLevel</code> 指定了目录展示的最大层次.这里只会展示两级.</p><p>响应示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img class=&quot;editor-inline-macro&quot; src=&quot;/plugins/servlet/confluence/placeholder/macro?definition=e3RvYzptYXhMZXZlbD0yfQ&amp;amp;locale=zh_CN&amp;amp;version=2&quot; data-macro-name=&quot;toc&quot; data-macro-parameters=&quot;maxLevel=2&quot; data-macro-schema-version=&quot;1&quot;&gt;</span><br></pre></td></tr></table></figure><p>这里返回的信息需要保存下面, 后面还会使用到.</p><h2 id="目录宏-draft"><a href="#目录宏-draft" class="headerlink" title="目录宏 draft"></a>目录宏 draft</h2><p>发起 <code>/rest/tinymce/1/drafts</code> 请求.请求示例如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"draftId"</span>:<span class="string">"6488067"</span>,</span><br><span class="line">    <span class="attr">"pageId"</span>:<span class="string">"6488066"</span>,</span><br><span class="line">    <span class="attr">"parentPageId"</span>:<span class="string">"5898241"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"page"</span>,</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"markdown测试"</span>,</span><br><span class="line">    <span class="attr">"spaceKey"</span>:<span class="string">"SPC"</span>,</span><br><span class="line">    <span class="attr">"content"</span>:<span class="string">"&lt;p&gt;&lt;img class="</span>editor-inline-macro<span class="string">" src="</span>http://localhost:<span class="number">8090</span>/plugins/servlet/confluence/placeholder/macro?definition=e3RvYzptYXhMZXZlbD0yfQ&amp;locale=zh_CN&amp;version=<span class="number">2</span><span class="string">" data-macro-name="</span>toc<span class="string">" data-macro-parameters="</span>maxLevel=<span class="number">2</span><span class="string">" data-macro-schema-version="</span><span class="number">1</span><span class="string">" /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;"</span>,</span><br><span class="line">    <span class="attr">"syncRev"</span>:<span class="string">"0.izAFz9oUJgl5fEP4WzBEKKI.1"</span>,</span><br><span class="line">    <span class="attr">"pageVersion"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到之前请求返回的数据在这步操作中需要使用到.</p><h2 id="插入-markdown-宏"><a href="#插入-markdown-宏" class="headerlink" title="插入 markdown 宏"></a>插入 markdown 宏</h2><p>和插入目录宏类似.只是请求参数稍有变化:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"contentId"</span>:<span class="string">"6488066"</span>,</span><br><span class="line">    <span class="attr">"macro"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"markdown"</span>,</span><br><span class="line">        <span class="attr">"params"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"body"</span>:<span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到很简单, 就是 <code>name</code> 指定为 <code>markdown</code>.响应示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table class=&quot;wysiwyg-macro&quot; data-macro-name=&quot;markdown&quot; data-macro-schema-version=&quot;1&quot; style=&quot;background-image: url(/plugins/servlet/confluence/placeholder/macro-heading?definition=e21hcmtkb3dufQ&amp;amp;locale=zh_CN&amp;amp;version=2); background-repeat: no-repeat;&quot; data-macro-body-type=&quot;PLAIN_TEXT&quot;&gt;&lt;tr&gt;&lt;td class=&quot;wysiwyg-macro-body&quot;&gt;&lt;pre /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>这里返回的内容也需要保存下来, 后面的操作需要使用到.</p><h2 id="更新文档-draft-status"><a href="#更新文档-draft-status" class="headerlink" title="更新文档(draft status)"></a>更新文档(draft status)</h2><p>这是最后一步, 发起 <code>/rest/api/content/{id}?status=draft</code> 请求.请求示例如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"current"</span>,</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"markdown测试"</span>,</span><br><span class="line">    <span class="attr">"space"</span>:&#123;</span><br><span class="line">        <span class="attr">"key"</span>:<span class="string">"SPC"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"body"</span>:&#123;</span><br><span class="line">        <span class="attr">"editor"</span>:&#123;</span><br><span class="line">            <span class="attr">"value"</span>:<span class="string">"&lt;p&gt;&lt;img class="</span>editor-inline-macro<span class="string">" src="</span>http://localhost:<span class="number">8090</span>/plugins/servlet/confluence/placeholder/macro?definition=e3RvYzptYXhMZXZlbD0yfQ&amp;locale=zh_CN&amp;version=<span class="number">2</span><span class="string">" data-macro-name="</span>toc<span class="string">" data-macro-parameters="</span>maxLevel=<span class="number">2</span><span class="string">" data-macro-schema-version="</span><span class="number">1</span><span class="string">" data-macro-id="</span><span class="number">50</span>c89389<span class="number">-2</span>ea5<span class="number">-43</span>cf-a582-d5b2ed3d4796<span class="string">" /&gt;&lt;/p&gt;&lt;table class="</span>wysiwyg-macro<span class="string">" style="</span>background-image: url('http://localhost:<span class="number">8090</span>/plugins/servlet/confluence/placeholder/macro-heading?definition=e21hcmtkb3dufQ&amp;locale=zh_CN&amp;version=<span class="number">2</span>'); background-repeat: no-repeat;<span class="string">" data-macro-name="</span>markdown<span class="string">" data-macro-schema-version="</span><span class="number">1</span><span class="string">" data-macro-body-type="</span>PLAIN_TEXT<span class="string">"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="</span>wysiwyg-macro-body<span class="string">"&gt;&lt;pre&gt;# 概要&lt;br /&gt;&lt;br /&gt;本文档描述了...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;"</span>,</span><br><span class="line">            <span class="attr">"representation"</span>:<span class="string">"editor"</span>,</span><br><span class="line">            <span class="attr">"content"</span>:&#123;</span><br><span class="line">                <span class="attr">"id"</span>:<span class="string">"6488066"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"id"</span>:<span class="string">"6488066"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"page"</span>,</span><br><span class="line">    <span class="attr">"version"</span>:&#123;</span><br><span class="line">        <span class="attr">"number"</span>:<span class="number">5</span>,</span><br><span class="line">        <span class="attr">"message"</span>:<span class="string">""</span>,</span><br><span class="line">        <span class="attr">"minorEdit"</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"syncRev"</span>:<span class="string">"0.yM8srPzow93w6esMsDjIuXE.2"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"ancestors"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>:<span class="string">"5898241"</span>,</span><br><span class="line">            <span class="attr">"type"</span>:<span class="string">"page"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现请求中的 <code>editor</code> 中的数据, 是把第一步和第三步返回的数据拼接在了一起, 并且在第三步返回的数据中插入了我们实际要写入的 mardown 的内容.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table class=&quot;...&quot; style=&quot;...&quot; data-macro-body-type=&quot;...&quot;&gt;&lt;tr&gt;&lt;td class=&quot;...&quot;&gt;在这里插入实际的 markdown 内容&lt;pre /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>通过以上的 4 个步骤我们就可以完成通过程序自动化地在 confluence 中创建 markdown 文档.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 confluence 中创建 markdown 文档, 首先需要安装相关的 markdown 插件.既有免费的, 也有付费的.经过试用付费的 markdown 插件, 和免费的对比一下, 发现大部分 markdown 相关的功能都基本一致.付费的提供了一些额外的特性, 
      
    
    </summary>
    
      <category term="文档工具" scheme="https://ykgarfield.github.io/categories/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
    
      <category term="confluence" scheme="https://ykgarfield.github.io/categories/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/confluence/"/>
    
    
      <category term="confluence" scheme="https://ykgarfield.github.io/tags/confluence/"/>
    
      <category term="confluence markdown" scheme="https://ykgarfield.github.io/tags/confluence-markdown/"/>
    
  </entry>
  
  <entry>
    <title>confluence-记一次 confluence markdown 表格样式不美观发生的事</title>
    <link href="https://ykgarfield.github.io/2018/12/23/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/confluence/confluence-%E8%AE%B0%E4%B8%80%E6%AC%A1-confluence-markdown-%E8%A1%A8%E6%A0%BC%E6%A0%B7%E5%BC%8F%E4%B8%8D%E7%BE%8E%E8%A7%82%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B/"/>
    <id>https://ykgarfield.github.io/2018/12/23/文档工具/confluence/confluence-记一次-confluence-markdown-表格样式不美观发生的事/</id>
    <published>2018-12-22T16:00:00.000Z</published>
    <updated>2019-01-01T14:55:22.553Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用 confluence markdown 插件(免费)的时候, 发现生成的表格样式实在不太美观, 甚至有点丑陋:</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/记一次_confluence_markdown_表格样式丑陋发生的事/markdown-table-style-ugly.jpg" alt="markdown-table-style-ugly"></p><p>再看看 confluence 原生表格的样式做个对比:</p><p><img src="https://www.github.com/ykgarfield/my-blog/raw/master/images/记一次_confluence_markdown_表格样式丑陋发生的事/markdown-native-table-style-diff.jpg" alt="markdown-native-table-style-diff"></p><p>不知道之前用 markdown 插件写作的人是怎么能忍受这种表格样式的.</p><p>于是乎就去评论了一下, 没想到的是很快就得到了回复.详情可见: <a href="https://marketplace.atlassian.com/apps/1211438/markdown-macro-for-confluence?hosting=server&amp;tab=reviews" target="_blank" rel="noopener">https://marketplace.atlassian.com/apps/1211438/markdown-macro-for-confluence?hosting=server&amp;tab=reviews</a></p><p>接下来就继续与作者进行沟通, 不过并没有抱太大期望.意外不到的是, 作者提供了一个新版本的插件 jar 包给我, 让我试试看, 有些意外和惊喜.</p><p>后面的沟通都是通过 <a href="https://atlasauthority.atlassian.net/servicedesk/customer/portal/1/SUPPORT-111" target="_blank" rel="noopener">https://atlasauthority.atlassian.net/servicedesk/customer/portal/1/SUPPORT-111</a></p><p>因为一开始并不太熟悉怎么进行升级, 所以一开始升级的时候出了问题.在 <code>SUPPORT-111</code> 也有详细描述, 后来重新思考, 通过 <code>Atlassian Marketplace -&gt; 管理插件 -&gt; 上传插件</code> 的方式进行更新.更新完成之后, 表格的样式终于有了变化, 使用了 confluence 本地的样式.</p><p>此插件也于 2018.12.24 发布了新版本.</p><p>回顾整件事, 其实也是一个无心之举, 只是想去吐槽下.没想到作者也比较热心, 很快就对这个问题进行了修改.再此, 还是很感谢作者把免费插件做的这么好.</p><p>所以再使用 confluence 插件的时候, 如果觉得有做的不好的地方, 其实也是可以和作者进行沟通的, 说不定提出的建议就被采纳了.^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在用 confluence markdown 插件(免费)的时候, 发现生成的表格样式实在不太美观, 甚至有点丑陋:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/ykgarfield/my-blog/raw/master/images
      
    
    </summary>
    
      <category term="文档工具" scheme="https://ykgarfield.github.io/categories/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
    
      <category term="confluence" scheme="https://ykgarfield.github.io/categories/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/confluence/"/>
    
    
      <category term="confluence" scheme="https://ykgarfield.github.io/tags/confluence/"/>
    
      <category term="confluence markdown" scheme="https://ykgarfield.github.io/tags/confluence-markdown/"/>
    
  </entry>
  
</feed>
